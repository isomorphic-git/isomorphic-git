{"version":3,"sources":["webpack://BrowserFS/webpack/universalModuleDefinition","webpack://BrowserFS/webpack/bootstrap","webpack://BrowserFS/./node_modules/readable-stream/lib/_stream_duplex.js","webpack://BrowserFS/./node_modules/inherits/inherits_browser.js","webpack://BrowserFS/../ts/index.ts","webpack://BrowserFS/./node_modules/core-util-is/lib/util.js","webpack://BrowserFS/(webpack)/buildin/global.js","webpack://BrowserFS/./node_modules/events/events.js","webpack://BrowserFS/./node_modules/process-nextick-args/index.js","webpack://BrowserFS/./node_modules/safe-buffer/index.js","webpack://BrowserFS/./build/temp/library/webpack/BFSBuffer.js","webpack://BrowserFS/./node_modules/buffer/index.js","webpack://BrowserFS/./node_modules/readable-stream/readable-browser.js","webpack://BrowserFS/./node_modules/readable-stream/lib/_stream_writable.js","webpack://BrowserFS/../ts/path.ts","webpack://BrowserFS/./node_modules/readable-stream/lib/_stream_readable.js","webpack://BrowserFS/./node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack://BrowserFS/./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack://BrowserFS/./node_modules/string_decoder/lib/string_decoder.js","webpack://BrowserFS/./node_modules/readable-stream/lib/_stream_transform.js","webpack://BrowserFS/./build/temp/library/rollup/browserfs.rollup.js","webpack://BrowserFS/./node_modules/base64-js/index.js","webpack://BrowserFS/./node_modules/ieee754/index.js","webpack://BrowserFS/../ts/process.ts","webpack://BrowserFS/../ts/tty.ts","webpack://BrowserFS/./node_modules/stream-browserify/index.js","webpack://BrowserFS/./node_modules/isarray/index.js","webpack://BrowserFS/./node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack://BrowserFS/./node_modules/util-deprecate/browser.js","webpack://BrowserFS/./node_modules/readable-stream/lib/_stream_passthrough.js","webpack://BrowserFS/./node_modules/readable-stream/writable-browser.js","webpack://BrowserFS/./node_modules/readable-stream/duplex-browser.js","webpack://BrowserFS/./node_modules/readable-stream/transform.js","webpack://BrowserFS/./node_modules/readable-stream/passthrough.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","pna","objectKeys","keys","obj","push","Duplex","util","inherits","Readable","Writable","v","length","method","options","readable","writable","allowHalfOpen","once","onend","_writableState","ended","nextTick","onEndNT","self","end","highWaterMark","undefined","_readableState","destroyed","set","_destroy","err","cb","ctor","superCtor","super_","constructor","configurable","TempCtor","process","processProxy","defineKey","apply","arguments","initializeTTYs","stdin","stdout","stderr","Buffer","objectToString","toString","isArray","arg","Array","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","re","isObject","isDate","isError","e","Error","isFunction","isPrimitive","isBuffer","g","Function","eval","window","EventEmitter","_events","_maxListeners","defaultMaxListeners","setMaxListeners","isNaN","TypeError","emit","type","er","handler","len","args","listeners","error","context","slice","addListener","listener","newListener","warned","console","trace","on","fired","removeListener","list","position","splice","removeAllListeners","listenerCount","evlistener","emitter","version","indexOf","fn","arg1","arg2","arg3","buffer","copyProps","src","dst","SafeBuffer","encodingOrOffset","from","alloc","allocUnsafe","allocUnsafeSlow","size","fill","encoding","buf","SlowBuffer","base64","ieee754","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","Uint8Array","__proto__","isArrayBuffer","array","byteOffset","byteLength","fromArrayBuffer","string","isEncoding","actual","write","fromString","checked","copy","ArrayBuffer","isView","numberIsNaN","fromArrayLike","data","fromObject","assertSize","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","swap","b","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","arr","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","charCodeAt","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","start","fromByteArray","utf8Slice","Math","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","foo","typedArraySupport","species","poolSize","_isBuffer","compare","a","x","y","concat","pos","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","toLocaleString","equals","inspect","max","match","join","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","code","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","split","trim","replace","base64clean","Stream","Transform","PassThrough","global","CorkedRequest","state","_this","next","entry","finish","corkReq","callback","pendingcb","corkedRequestsFree","onCorkedFinish","asyncWrite","browser","setImmediate","WritableState","internalUtil","deprecate","OurUint8Array","realHasInstance","destroyImpl","nop","stream","isDuplex","objectMode","writableObjectMode","hwm","writableHwm","writableHighWaterMark","defaultHwm","floor","finalCalled","needDrain","ending","finished","noDecode","decodeStrings","defaultEncoding","writing","corked","sync","bufferProcessing","onwrite","writecb","writelen","onwriteStateUpdate","finishMaybe","errorEmitted","onwriteError","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","prefinished","bufferedRequestCount","_write","writev","_writev","destroy","final","_final","doWrite","chunk","onwriteDrain","holder","count","allBuffers","isBuf","callFinal","need","prefinish","getBuffer","current","_","hasInstance","pipe","_isUint8Array","_uint8ArrayToBuffer","writeAfterEnd","valid","validChunk","newChunk","decodeChunk","last","writeOrBuffer","cork","uncork","setDefaultEncoding","endWritable","_undestroy","undestroy","splitPathRe","path","normalize","absolute","charAt","sep","components","_removeDuplicateSeps","goodComponents","idx","pop","unshift","paths","_i","processed","segment","resolve","resolved","cwd","relative","to","fromSegs","toSegs","shift","upCount","downSegs","rv","dirname","sections","basename","lastPart","extname","isAbsolute","_makeLong","parse","allParts","filename","exec","posixSplitPath","base","format","pathObject","_replaceRegex","RegExp","delimiter","posix","win32","ReadableState","EElistenerCount","debugUtil","debug","debuglog","StringDecoder","BufferList","kProxyEvents","readableObjectMode","readableHwm","readableHighWaterMark","pipes","pipesCount","flowing","endEmitted","reading","needReadable","emittedReadable","readableListening","resumeScheduled","awaitDrain","readingMore","decoder","_read","readableAddChunk","addToFront","skipChunkCheck","emitReadable","onEofChunk","chunkInvalid","getPrototypeOf","addChunk","maybeReadMore","needMoreData","isPaused","setEncoding","enc","MAX_HWM","howMuchToRead","head","computeNewHighWaterMark","emitReadable_","flow","maybeReadMore_","nReadingNextTick","resume_","fromList","clear","hasStrings","nb","tail","copyFromBufferString","copyFromBuffer","fromListPartial","endReadable","endReadableNT","xs","nOrig","doRead","dest","pipeOpts","endFn","unpipe","onunpipe","unpipeInfo","hasUnpiped","onclose","onfinish","ondrain","onerror","ondata","cleanedUp","pipeOnDrain","increasedAwaitDrain","pause","event","prependListener","resume","dests","index","ev","wrap","paused","_fromList","emitErrorNT","readableDestroyed","writableDestroyed","nenc","retried","_normalizeEncoding","normalizeEncoding","text","utf16Text","utf16End","fillLast","utf8FillLast","base64Text","base64End","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","utf8CheckByte","byte","utf8CheckExtraBytes","total","utf8CheckIncomplete","_transformState","afterTransform","ts","transforming","writechunk","rs","needTransform","writeencoding","transform","_transform","flush","_flush","done","_this2","err2","ErrorCode","ErrorStrings","EPERM","ENOENT","EIO","EBADF","EACCES","EBUSY","EEXIST","ENOTDIR","EISDIR","EINVAL","EFBIG","ENOSPC","EROFS","ENOTEMPTY","ENOTSUP","ActionType","ApiError","message","path$$1","syscall","errno","stack","fromJSON","json","fromBuffer","buffer$$1","JSON","FileError","writeToBuffer","bufferSize","bytesWritten","stringify","api_error","freeze","FileType","FileFlag","flagStr","validFlagStrs","getFileFlag","flagCache","getFlagString","isReadable","isWriteable","isTruncating","isAppendable","isSynchronous","isExclusive","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","NOP","pathNotExistsAction","CREATE_FILE","Stats","itemType","atimeMs","mtimeMs","ctimeMs","birthtimeMs","dev","ino","rdev","nlink","blksize","uid","gid","fileData","currentTime","Date","now","FILE","DIRECTORY","blocks","ceil","prototypeAccessors","atime","mtime","ctime","birthtime","clone","toBuffer","getTime","isFile","isDirectory","isSymbolicLink","SYMLINK","chmod","isSocket","isBlockDevice","isCharacterDevice","isFIFO","defineProperties","bfsSetImmediate","toExport","gScope","timeouts","importScripts","postMessage","postMessageIsAsync","oldOnMessage","onmessage","canUsePostMessage","handleMessage","source","stopPropagation","cancelBubble","addEventListener","attachEvent","MessageChannel","channel","port1","port2","setTimeout","setImmediate$1","wrapCbHook","numArgs","wrapCb","hookedCb","assertRoot","fs","normalizeMode","def","trueMode","normalizeTime","time","normalizePath","normalizeOptions","defEnc","defFlag","defMode","flag","nopCb","FS","F_OK","R_OK","W_OK","X_OK","fdMap","nextFd","initialize","rootFS","isAvailable","_toUnixTimestamp","getRootFS","rename","oldPath","newPath","newCb","renameSync","exists","existsSync","stat","statSync","lstat","lstatSync","truncate","truncateSync","unlink","unlinkSync","open","this$1","file","getFdForFile","openSync","readFile","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","fstat","fd","fd2file","fstatSync","close","closeFd","closeSync","ftruncate","ftruncateSync","fsync","fsyncSync","syncSync","fdatasync","datasync","fdatasyncSync","datasyncSync","arg4","arg5","getPos","writeSync","bytesRead","readSync","shenanigans","fchown","chown","fchownSync","chownSync","fchmod","numMode","fchmodSync","chmodSync","futimes","utimes","futimesSync","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","link","srcpath","dstpath","linkSync","symlink","symlinkSync","readlink","readlinkSync","lchown","lchownSync","lchmod","lchmodSync","realpath","cache","realpathSync","watchFile","unwatchFile","watch","access","accessSync","createReadStream","createWriteStream","wrapCallbacks","cbWrapper","_fsMock","fsProto","_min","d0","d1","d2","bx","ay","forEach","newFs","isIE","navigator","userAgent","isWebWorker","fail","buffer2ArrayBuffer","buff","u8","buffer2Uint8array","u8offset","u8Len","uint8Array2Buffer","arrayBuffer2Buffer","ab","emptyBuff","emptyBuffer","checkOptions","fsType","opts","optsInfo","Options","fsName","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","loop","optName","opt","providedValue","optional","incorrectOptions","filter","map","distance","tmp","la","lb","d3","vector","bx0","bx1","bx2","bx3","dd$1","y$1","dy","dd","bx0$1","y$2","dy$1","levenshtein","sort","validator","returned","BFSUtils","deprecationMessage","print","warn","mkdirpSync","arrayish2Buffer","copyingSlice","s0","newS0","bufferValidator","BFSEmscriptenStreamOps","nodefs","getNodeFS","getFS","PATH","getPATH","ERRNO_CODES","getERRNO_CODES","realPath","node","nfd","flagsToPermissionString","flags","ErrnoError","llseek","whence","BFSEmscriptenNodeOps","getattr","setattr","attr","timestamp","date","lookup","parent","join2","getMode","createNode","mknod","isDir","oldNode","newDir","newName","contents","BFSEmscriptenFS","_FS","_PATH","_ERRNO_CODES","flagsToPermissionStringMap","0","1","2","64","65","66","129","193","514","577","578","705","706","1024","1025","1026","1089","1090","1153","1154","1217","1218","4096","4098","node_ops","stream_ops","mount","isLink","parts","reverse","parsedFlags","BaseFileSystem","supportsLinks","diskSpace","openFile","createFile","stats","parentStats","isLstat","openFileSync","createFileSync","splitPath","addPaths","doesExist","er2","fname","oldCb","isLchmod","isLchown","SynchronousFileSystem","supportsSynch","Inode","id","toStats","getSize","update","hasChanged","BaseFile","PreloadFile","BaseFile$$1","_fs","_path","_flag","_stat","_pos","_dirty","_buffer","getStats","getFlag","getPath","advancePos","delta","setPos","newPos","newBuff","endFp","supportsProps","isDirty","resetDirty","emptyDirNode","NoSyncFile","getEmptyDirNode","GenerateRandomID","random","noError","noErrorTx","tx","abort","LRUNode","prev","LRUCache","remove","setHead","removeAll","SimpleSyncRWTransaction","store","originalData","modifiedKeys","stashOldValue","put","overwrite","markModified","del","commit","SyncKeyValueFile","PreloadFile$$1","_syncSync","SyncKeyValueFileSystem","SynchronousFileSystem$$1","makeRootDirectory","getName","isReadOnly","supportsSymlinks","empty","beginTransaction","oldParent","oldName","newParent","oldDirNode","findINode","oldDirList","getDirListing","newDirNode","newDirList","nodeId","newNameNode","getINode","newFile","commitNewFile","removeEntry","fileInodeId","_findINode","fileInode","inodeChanged","currTime","dirInode","readDirectory","inode","dirList","addNewNode","currId","fileNode","parentDir","parentNode","dirListing","dataId","fileNodeId","parentListing","fileName","AsyncKeyValueFile","_sync","AsyncKeyValueFileSystem","BaseFileSystem$$1","cacheSize","_cache","init","inodes","lists","errorOccurred","processInodeAndListings","findINodeAndDirListing","oldParentList","oldParentINode","newParentList","newParentINode","fileId","completeRename","theOleSwitcharoo","files","handleDirectoryListings","listing","retries","reroll","committed","InMemoryStore","InMemoryFileSystem","SyncKeyValueFileSystem$$1","Create","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","convertError","onErrorHandler","preventDefault","IndexedDBROTransaction","onsuccess","result","IndexedDBRWTransaction","arraybuffer","add","_e","IndexedDBStore","db","storeName","openReq","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","IndexedDBFileSystem","transaction","objectStore","AsyncKeyValueFileSystem$$1","idbfs","description","oneArg","normalizedCb","normalizedOpts","Backends","InMemory","IndexedDB","BFSRequire","rootfs","getFileSystem","config","waitCount","called","fsc","finishedIterating","k","install","oldRequire","require","registerFileSystem","configure","EmscriptenFS","FileSystem","Errors","b64","lens","getLens","validLen","placeHoldersLen","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","len2","encodeChunk","tripletToBase64","num","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","log","LN2","events","Item","fun","run","NextTickQueue","_queue","_draining","_currentQueue","_queueIndex","item","_drainQueue","_cleanUpNextTick","timeout","clearTimeout","Process","_super","startTime","_cwd","platform","argv","execArgv","domain","execPath","__dirname","env","exitCode","_gid","_uid","versions","http_parser","v8","uv","zlib","ares","icu","openssl","target_defaults","cflags","default_configuration","defines","include_dirs","libraries","variables","clang","host_arch","node_install_npm","node_install_waf","node_prefix","node_shared_cares","node_shared_http_parser","node_shared_libuv","node_shared_zlib","node_shared_v8","node_use_dtrace","node_use_etw","node_use_openssl","node_shared_openssl","strict_aliasing","target_arch","v8_use_snapshot","v8_no_strict_aliasing","visibility","pid","title","arch","_mask","connected","__extends","chdir","uptime","exit","getgid","setgid","getuid","setuid","kill","signal","memoryUsage","rss","heapTotal","heapUsed","umask","mask","oldMask","hrtime","timeinfo","secs","performance","TTY","disconnect","isRaw","columns","rows","isTTY","_bufferedWrites","_waitingForWrites","setRawMode","changeColumns","changeRows","isatty","EE","_isStdio","didOnEnd","cleanup","copyBuffer","instance","Constructor","_classCallCheck","custom","localStorage","msg"],"mappings":"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","file":"../build/browserfs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"BrowserFS\"] = factory();\n\telse\n\t\troot[\"BrowserFS\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","import Process = require('./process');\nimport TTD = require('./tty');\n\nvar process = new Process(),\n  processProxy: Process = <any> {};\n\nfunction defineKey(key: string) {\n  if ((<any> processProxy)[key]) {\n    // Probably a builtin Object property we don't care about.\n    return;\n  }\n  if (typeof (<any> process)[key] === 'function') {\n    (<any> processProxy)[key] = function() {\n      return (<Function> (<any> process)[key]).apply(process, arguments);\n    };\n  } else {\n    (<any> processProxy)[key] = (<any> process)[key];\n  }\n}\n\nfor (var key in process) {\n  // Don't check if process.hasOwnProperty; we want to also expose objects\n  // up the prototype hierarchy.\n  defineKey(key);\n}\n\n// Special key: Ensure we update public-facing values of stdin/stdout/stderr.\nprocessProxy.initializeTTYs = function() {\n  if (process.stdin === null) {\n    process.initializeTTYs();\n    processProxy.stdin = process.stdin;\n    processProxy.stdout = process.stdout;\n    processProxy.stderr = process.stderr;\n  }\n};\n\nprocess.nextTick(() => {\n  processProxy.initializeTTYs();\n});\n\nexport = processProxy;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = require('buffer').Buffer;\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  get: function () {\n    if (!(this instanceof Buffer)) {\n      return undefined\n    }\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  get: function () {\n    if (!(this instanceof Buffer)) {\n      return undefined\n    }\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (ArrayBuffer.isView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (ArrayBuffer.isView(buf)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","// Type information only.\nimport _path = require('path');\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nfunction posixSplitPath(filename: string): string[] {\n  var out = splitPathRe.exec(filename);\n  out.shift();\n  return out;\n}\n\n/**\n * Emulates Node's `path` module. This module contains utilities for handling and\n * transforming file paths. **All** of these methods perform only string\n * transformations. The file system is not consulted to check whether paths are\n * valid.\n * @see http://nodejs.org/api/path.html\n * @class\n */\nclass path {\n  /**\n   * Normalize a string path, taking care of '..' and '.' parts.\n   *\n   * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n   * @example Usage example\n   *   path.normalize('/foo/bar//baz/asdf/quux/..')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   * @param [String] p The path to normalize.\n   * @return [String]\n   */\n  public static normalize(p: string): string {\n    // Special case: '' -> '.'\n    if (p === '') {\n      p = '.';\n    }\n    // It's very important to know if the path is relative or not, since it\n    // changes how we process .. and reconstruct the split string.\n    var absolute = p.charAt(0) === path.sep;\n    // Remove repeated //s\n    p = path._removeDuplicateSeps(p);\n    // Try to remove as many '../' as possible, and remove '.' completely.\n    var components = p.split(path.sep);\n    var goodComponents: string[] = [];\n    for (var idx = 0; idx < components.length; idx++) {\n      var c = components[idx];\n      if (c === '.') {\n        continue;\n      } else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\n        // In the absolute case: Path is relative to root, so we may pop even if\n        // goodComponents is empty (e.g. /../ => /)\n        // In the relative case: We're getting rid of a directory that preceded\n        // it (e.g. /foo/../bar -> /bar)\n        goodComponents.pop();\n      } else {\n        goodComponents.push(c);\n      }\n    }\n\n    // Add in '.' when it's a relative path with no other nonempty components.\n    // Possible results: '.' and './' (input: [''] or [])\n    // @todo Can probably simplify this logic.\n    if (!absolute && goodComponents.length < 2) {\n      switch (goodComponents.length) {\n        case 1:\n          if (goodComponents[0] === '') {\n            goodComponents.unshift('.');\n          }\n          break;\n        default:\n          goodComponents.push('.');\n      }\n    }\n    p = goodComponents.join(path.sep);\n    if (absolute && p.charAt(0) !== path.sep) {\n      p = path.sep + p;\n    }\n    return p;\n  }\n\n  /**\n   * Join all arguments together and normalize the resulting path.\n   *\n   * Arguments must be strings.\n   * @example Usage\n   *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   *\n   *   path.join('foo', {}, 'bar')\n   *   // throws exception\n   *   TypeError: Arguments to path.join must be strings\n   * @param [String,...] paths Each component of the path\n   * @return [String]\n   */\n  public static join(...paths: any[]): string {\n    // Required: Prune any non-strings from the path. I also prune empty segments\n    // so we can do a simple join of the array.\n    var processed: string[] = [];\n    for (var i = 0; i < paths.length; i++) {\n      var segment = paths[i];\n      if (typeof segment !== 'string') {\n        throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\n      } else if (segment !== '') {\n        processed.push(segment);\n      }\n    }\n    return path.normalize(processed.join(path.sep));\n  }\n\n  /**\n   * Resolves to to an absolute path.\n   *\n   * If to isn't already absolute from arguments are prepended in right to left\n   * order, until an absolute path is found. If after using all from paths still\n   * no absolute path is found, the current working directory is used as well.\n   * The resulting path is normalized, and trailing slashes are removed unless\n   * the path gets resolved to the root directory. Non-string arguments are\n   * ignored.\n   *\n   * Another way to think of it is as a sequence of cd commands in a shell.\n   *\n   *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n   *\n   * Is similar to:\n   *\n   *     cd foo/bar\n   *     cd /tmp/file/\n   *     cd ..\n   *     cd a/../subfile\n   *     pwd\n   *\n   * The difference is that the different paths don't need to exist and may also\n   * be files.\n   * @example Usage example\n   *   path.resolve('/foo/bar', './baz')\n   *   // returns\n   *   '/foo/bar/baz'\n   *\n   *   path.resolve('/foo/bar', '/tmp/file/')\n   *   // returns\n   *   '/tmp/file'\n   *\n   *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n   *   // if currently in /home/myself/node, it returns\n   *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n   * @param [String,...] paths\n   * @return [String]\n   */\n  public static resolve(...paths: string[]): string {\n    // Monitor for invalid paths, throw out empty paths, and look for the *last*\n    // absolute path that we see.\n    var processed: string[] = [];\n    for (var i = 0; i < paths.length; i++) {\n      var p = paths[i];\n      if (typeof p !== 'string') {\n        throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\n      } else if (p !== '') {\n        // Remove anything that has occurred before this absolute path, as it\n        // doesn't matter.\n        if (p.charAt(0) === path.sep) {\n          processed = [];\n        }\n        processed.push(p);\n      }\n    }\n    // Special: Remove trailing slash unless it's the root\n    var resolved = path.normalize(processed.join(path.sep));\n    if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {\n      return resolved.substr(0, resolved.length - 1);\n    }\n    // Special: If it doesn't start with '/', it's relative and we need to append\n    // the current directory.\n    if (resolved.charAt(0) !== path.sep) {\n      // Remove ./, since we're going to append the current directory.\n      if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {\n        resolved = resolved.length === 1 ? '' : resolved.substr(2);\n      }\n      // Append the current directory, which *must* be an absolute path.\n      var cwd = process.cwd();\n      if (resolved !== '') {\n        // cwd will never end in a /... unless it's the root.\n        resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);\n      } else {\n        resolved = cwd;\n      }\n    }\n    return resolved;\n  }\n\n  /**\n   * Solve the relative path from from to to.\n   *\n   * At times we have two absolute paths, and we need to derive the relative path\n   * from one to the other. This is actually the reverse transform of\n   * path.resolve, which means we see that:\n   *\n   *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n   *\n   * @example Usage example\n   *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n   *   // returns\n   *   '..\\\\..\\\\impl\\\\bbb'\n   *\n   *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n   *   // returns\n   *   '../../impl/bbb'\n   * @param [String] from\n   * @param [String] to\n   * @return [String]\n   */\n  public static relative(from: string, to: string): string {\n    var i: number;\n    // Alright. Let's resolve these two to absolute paths and remove any\n    // weirdness.\n    from = path.resolve(from);\n    to = path.resolve(to);\n    var fromSegs = from.split(path.sep);\n    var toSegs = to.split(path.sep);\n    // Remove the first segment on both, as it's '' (both are absolute paths)\n    toSegs.shift();\n    fromSegs.shift();\n    // There are two segments to this path:\n    // * Going *up* the directory hierarchy with '..'\n    // * Going *down* the directory hierarchy with foo/baz/bat.\n    var upCount = 0;\n    var downSegs: string[] = [];\n    // Figure out how many things in 'from' are shared with 'to'.\n    for (i = 0; i < fromSegs.length; i++) {\n      var seg = fromSegs[i];\n      if (seg === toSegs[i]) {\n        continue;\n      }\n      // The rest of 'from', including the current element, indicates how many\n      // directories we need to go up.\n      upCount = fromSegs.length - i;\n      break;\n    }\n    // The rest of 'to' indicates where we need to change to. We place this\n    // outside of the loop, as toSegs.length may be greater than fromSegs.length.\n    downSegs = toSegs.slice(i);\n    // Special case: If 'from' is '/'\n    if (fromSegs.length === 1 && fromSegs[0] === '') {\n      upCount = 0;\n    }\n    // upCount can't be greater than the number of fromSegs\n    // (cd .. from / is still /)\n    if (upCount > fromSegs.length) {\n      upCount = fromSegs.length;\n    }\n    // Create the final string!\n    var rv = '';\n    for (i = 0; i < upCount; i++) {\n      rv += '../';\n    }\n    rv += downSegs.join(path.sep);\n    // Special case: Remove trailing '/'. Happens if it's all up and no down.\n    if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {\n      rv = rv.substr(0, rv.length - 1);\n    }\n    return rv;\n  }\n\n  /**\n   * Return the directory name of a path. Similar to the Unix `dirname` command.\n   *\n   * Note that BrowserFS does not validate if the path is actually a valid\n   * directory.\n   * @example Usage example\n   *   path.dirname('/foo/bar/baz/asdf/quux')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   * @param [String] p The path to get the directory name of.\n   * @return [String]\n   */\n  public static dirname(p: string): string {\n    // We get rid of //, but we don't modify anything else (e.g. any extraneous .\n    // and ../ are kept intact)\n    p = path._removeDuplicateSeps(p);\n    var absolute = p.charAt(0) === path.sep;\n    var sections = p.split(path.sep);\n    // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\n    if (sections.pop() === '' && sections.length > 0) {\n      sections.pop();\n    }\n    // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\n    // If not absolute, the first section is the first part of the path, and is OK\n    // to return.\n    if (sections.length > 1 || (sections.length === 1 && !absolute)) {\n      return sections.join(path.sep);\n    } else if (absolute) {\n      return path.sep;\n    } else {\n      return '.';\n    }\n  }\n\n  /**\n   * Return the last portion of a path. Similar to the Unix basename command.\n   * @example Usage example\n   *   path.basename('/foo/bar/baz/asdf/quux.html')\n   *   // returns\n   *   'quux.html'\n   *\n   *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n   *   // returns\n   *   'quux'\n   * @param [String] p\n   * @param [String?] ext\n   * @return [String]\n   */\n  public static basename(p: string, ext: string = \"\"): string {\n    // Special case: Normalize will modify this to '.'\n    if (p === '') {\n      return p;\n    }\n    // Normalize the string first to remove any weirdness.\n    p = path.normalize(p);\n    // Get the last part of the string.\n    var sections = p.split(path.sep);\n    var lastPart = sections[sections.length - 1];\n    // Special case: If it's empty, then we have a string like so: foo/\n    // Meaning, 'foo' is guaranteed to be a directory.\n    if (lastPart === '' && sections.length > 1) {\n      return sections[sections.length - 2];\n    }\n    // Remove the extension, if need be.\n    if (ext.length > 0) {\n      var lastPartExt = lastPart.substr(lastPart.length - ext.length);\n      if (lastPartExt === ext) {\n        return lastPart.substr(0, lastPart.length - ext.length);\n      }\n    }\n    return lastPart;\n  }\n\n  /**\n   * Return the extension of the path, from the last '.' to end of string in the\n   * last portion of the path. If there is no '.' in the last portion of the path\n   * or the first character of it is '.', then it returns an empty string.\n   * @example Usage example\n   *   path.extname('index.html')\n   *   // returns\n   *   '.html'\n   *\n   *   path.extname('index.')\n   *   // returns\n   *   '.'\n   *\n   *   path.extname('index')\n   *   // returns\n   *   ''\n   * @param [String] p\n   * @return [String]\n   */\n  public static extname(p: string): string {\n    p = path.normalize(p);\n    var sections = p.split(path.sep);\n    p = sections.pop();\n    // Special case: foo/file.ext/ should return '.ext'\n    if (p === '' && sections.length > 0) {\n      p = sections.pop();\n    }\n    if (p === '..') {\n      return '';\n    }\n    var i = p.lastIndexOf('.');\n    if (i === -1 || i === 0) {\n      return '';\n    }\n    return p.substr(i);\n  }\n\n  /**\n   * Checks if the given path is an absolute path.\n   *\n   * Despite not being documented, this is a tested part of Node's path API.\n   * @param [String] p\n   * @return [Boolean] True if the path appears to be an absolute path.\n   */\n  public static isAbsolute(p: string): boolean {\n    return p.length > 0 && p.charAt(0) === path.sep;\n  }\n\n  /**\n   * Unknown. Undocumented.\n   */\n  public static _makeLong(p: string): string {\n    return p;\n  }\n\n  /**\n   * Returns an object from a path string.\n   */\n  public static parse(p: string): _path.ParsedPath {\n    var allParts = posixSplitPath(p);\n    return {\n      root: allParts[0],\n      dir: allParts[0] + allParts[1].slice(0, -1),\n      base: allParts[2],\n      ext: allParts[3],\n      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n    };\n  }\n\n  public static format(pathObject: _path.ParsedPath): string {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(`Parameter 'pathObject' must be an object, not ${typeof pathObject}`);\n    }\n\n    var root = pathObject.root || '';\n\n    if (typeof root !== 'string') {\n      throw new TypeError(\n          \"'pathObject.root' must be a string or undefined, not \" +\n          typeof pathObject.root\n      );\n    }\n\n    var dir = pathObject.dir ? pathObject.dir + path.sep : '';\n    var base = pathObject.base || '';\n    return dir + base;\n  }\n\n  // The platform-specific file separator. BrowserFS uses `/`.\n  public static sep: string = '/';\n\n  private static _replaceRegex = new RegExp(\"//+\", 'g');\n\n  private static _removeDuplicateSeps(p: string): string {\n    p = p.replace(this._replaceRegex, this.sep);\n    return p;\n  }\n\n  // The platform-specific path delimiter. BrowserFS uses `:`.\n  public static delimiter = ':';\n\n  public static posix = path;\n  // XXX: Typing hack. We don't actually support win32.\n  public static win32 = path;\n}\n\nvar _: typeof _path = path;\n\nexport = path;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","module.exports = require('events').EventEmitter;\n","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar path = require('path');\nvar buffer = require('buffer');\n\n/**\n * Standard libc error codes. Add more to this enum and ErrorStrings as they are\n * needed.\n * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"EPERM\"] = 1] = \"EPERM\";\n    ErrorCode[ErrorCode[\"ENOENT\"] = 2] = \"ENOENT\";\n    ErrorCode[ErrorCode[\"EIO\"] = 5] = \"EIO\";\n    ErrorCode[ErrorCode[\"EBADF\"] = 9] = \"EBADF\";\n    ErrorCode[ErrorCode[\"EACCES\"] = 13] = \"EACCES\";\n    ErrorCode[ErrorCode[\"EBUSY\"] = 16] = \"EBUSY\";\n    ErrorCode[ErrorCode[\"EEXIST\"] = 17] = \"EEXIST\";\n    ErrorCode[ErrorCode[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\n    ErrorCode[ErrorCode[\"EISDIR\"] = 21] = \"EISDIR\";\n    ErrorCode[ErrorCode[\"EINVAL\"] = 22] = \"EINVAL\";\n    ErrorCode[ErrorCode[\"EFBIG\"] = 27] = \"EFBIG\";\n    ErrorCode[ErrorCode[\"ENOSPC\"] = 28] = \"ENOSPC\";\n    ErrorCode[ErrorCode[\"EROFS\"] = 30] = \"EROFS\";\n    ErrorCode[ErrorCode[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\n    ErrorCode[ErrorCode[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\n})(ErrorCode || (ErrorCode = {}));\n/* tslint:disable:variable-name */\n/**\n * Strings associated with each error code.\n * @hidden\n */\nvar ErrorStrings = {};\nErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';\nErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';\nErrorStrings[ErrorCode.EIO] = 'Input/output error.';\nErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';\nErrorStrings[ErrorCode.EACCES] = 'Permission denied.';\nErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';\nErrorStrings[ErrorCode.EEXIST] = 'File exists.';\nErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';\nErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';\nErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';\nErrorStrings[ErrorCode.EFBIG] = 'File is too big.';\nErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';\nErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';\nErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';\nErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';\n/* tslint:enable:variable-name */\n/**\n * Represents a BrowserFS error. Passed back to applications after a failed\n * call to the BrowserFS API.\n */\nvar ApiError = (function (Error) {\n    function ApiError(type, message, path$$1) {\n        if ( message === void 0 ) message = ErrorStrings[type];\n\n        Error.call(this, message);\n        // Unsupported.\n        this.syscall = \"\";\n        this.errno = type;\n        this.code = ErrorCode[type];\n        this.path = path$$1;\n        this.stack = new Error().stack;\n        this.message = \"Error: \" + (this.code) + \": \" + message + (this.path ? (\", '\" + (this.path) + \"'\") : '');\n    }\n\n    if ( Error ) ApiError.__proto__ = Error;\n    ApiError.prototype = Object.create( Error && Error.prototype );\n    ApiError.prototype.constructor = ApiError;\n    ApiError.fromJSON = function fromJSON (json) {\n        var err = new ApiError(0);\n        err.errno = json.errno;\n        err.code = json.code;\n        err.path = json.path;\n        err.stack = json.stack;\n        err.message = json.message;\n        return err;\n    };\n    /**\n     * Creates an ApiError object from a buffer.\n     */\n    ApiError.fromBuffer = function fromBuffer (buffer$$1, i) {\n        if ( i === void 0 ) i = 0;\n\n        return ApiError.fromJSON(JSON.parse(buffer$$1.toString('utf8', i + 4, i + 4 + buffer$$1.readUInt32LE(i))));\n    };\n    ApiError.FileError = function FileError (code, p) {\n        return new ApiError(code, ErrorStrings[code], p);\n    };\n    ApiError.ENOENT = function ENOENT (path$$1) {\n        return this.FileError(ErrorCode.ENOENT, path$$1);\n    };\n    ApiError.EEXIST = function EEXIST (path$$1) {\n        return this.FileError(ErrorCode.EEXIST, path$$1);\n    };\n    ApiError.EISDIR = function EISDIR (path$$1) {\n        return this.FileError(ErrorCode.EISDIR, path$$1);\n    };\n    ApiError.ENOTDIR = function ENOTDIR (path$$1) {\n        return this.FileError(ErrorCode.ENOTDIR, path$$1);\n    };\n    ApiError.EPERM = function EPERM (path$$1) {\n        return this.FileError(ErrorCode.EPERM, path$$1);\n    };\n    ApiError.ENOTEMPTY = function ENOTEMPTY (path$$1) {\n        return this.FileError(ErrorCode.ENOTEMPTY, path$$1);\n    };\n    /**\n     * @return A friendly error message.\n     */\n    ApiError.prototype.toString = function toString () {\n        return this.message;\n    };\n    ApiError.prototype.toJSON = function toJSON () {\n        return {\n            errno: this.errno,\n            code: this.code,\n            path: this.path,\n            stack: this.stack,\n            message: this.message\n        };\n    };\n    /**\n     * Writes the API error into a buffer.\n     */\n    ApiError.prototype.writeToBuffer = function writeToBuffer (buffer$$1, i) {\n        if ( buffer$$1 === void 0 ) buffer$$1 = Buffer.alloc(this.bufferSize());\n        if ( i === void 0 ) i = 0;\n\n        var bytesWritten = buffer$$1.write(JSON.stringify(this.toJSON()), i + 4);\n        buffer$$1.writeUInt32LE(bytesWritten, i);\n        return buffer$$1;\n    };\n    /**\n     * The size of the API error in buffer-form in bytes.\n     */\n    ApiError.prototype.bufferSize = function bufferSize () {\n        // 4 bytes for string length.\n        return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\n    };\n\n    return ApiError;\n}(Error));\n\nvar api_error = /*#__PURE__*/Object.freeze({\n    get ErrorCode () { return ErrorCode; },\n    ErrorStrings: ErrorStrings,\n    ApiError: ApiError\n});\n\nvar ActionType;\n(function (ActionType) {\n    // Indicates that the code should not do anything.\n    ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\n    // Indicates that the code should throw an exception.\n    ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\n    // Indicates that the code should truncate the file, but only if it is a file.\n    ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\n    // Indicates that the code should create the file.\n    ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\n})(ActionType || (ActionType = {}));\n/**\n * Represents one of the following file flags. A convenience object.\n *\n * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n * * `'a'` - Open file for appending. The file is created if it does not exist.\n * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n *\n * Exclusive mode ensures that the file path is newly created.\n */\nvar FileFlag = function FileFlag(flagStr) {\n    this.flagStr = flagStr;\n    if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\n        throw new ApiError(ErrorCode.EINVAL, \"Invalid flag: \" + flagStr);\n    }\n};\n/**\n * Get an object representing the given file flag.\n * @param modeStr The string representing the flag\n * @return The FileFlag object representing the flag\n * @throw when the flag string is invalid\n */\nFileFlag.getFileFlag = function getFileFlag (flagStr) {\n    // Check cache first.\n    if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\n        return FileFlag.flagCache[flagStr];\n    }\n    return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\n};\n/**\n * Get the underlying flag string for this flag.\n */\nFileFlag.prototype.getFlagString = function getFlagString () {\n    return this.flagStr;\n};\n/**\n * Returns true if the file is readable.\n */\nFileFlag.prototype.isReadable = function isReadable () {\n    return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\n};\n/**\n * Returns true if the file is writeable.\n */\nFileFlag.prototype.isWriteable = function isWriteable () {\n    return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\n};\n/**\n * Returns true if the file mode should truncate.\n */\nFileFlag.prototype.isTruncating = function isTruncating () {\n    return this.flagStr.indexOf('w') !== -1;\n};\n/**\n * Returns true if the file is appendable.\n */\nFileFlag.prototype.isAppendable = function isAppendable () {\n    return this.flagStr.indexOf('a') !== -1;\n};\n/**\n * Returns true if the file is open in synchronous mode.\n */\nFileFlag.prototype.isSynchronous = function isSynchronous () {\n    return this.flagStr.indexOf('s') !== -1;\n};\n/**\n * Returns true if the file is open in exclusive mode.\n */\nFileFlag.prototype.isExclusive = function isExclusive () {\n    return this.flagStr.indexOf('x') !== -1;\n};\n/**\n * Returns one of the static fields on this object that indicates the\n * appropriate response to the path existing.\n */\nFileFlag.prototype.pathExistsAction = function pathExistsAction () {\n    if (this.isExclusive()) {\n        return ActionType.THROW_EXCEPTION;\n    }\n    else if (this.isTruncating()) {\n        return ActionType.TRUNCATE_FILE;\n    }\n    else {\n        return ActionType.NOP;\n    }\n};\n/**\n * Returns one of the static fields on this object that indicates the\n * appropriate response to the path not existing.\n */\nFileFlag.prototype.pathNotExistsAction = function pathNotExistsAction () {\n    if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\n        return ActionType.CREATE_FILE;\n    }\n    else {\n        return ActionType.THROW_EXCEPTION;\n    }\n};\n// Contains cached FileMode instances.\nFileFlag.flagCache = {};\n// Array of valid mode strings.\nFileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\n\n/**\n * Indicates the type of the given file. Applied to 'mode'.\n */\nvar FileType;\n(function (FileType) {\n    FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\n    FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\n    FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\n})(FileType || (FileType = {}));\n/**\n * Emulation of Node's `fs.Stats` object.\n *\n * Attribute descriptions are from `man 2 stat'\n * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\n * @see http://man7.org/linux/man-pages/man2/stat.2.html\n */\nvar Stats = function Stats(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\n    /**\n     * UNSUPPORTED ATTRIBUTES\n     * I assume no one is going to need these details, although we could fake\n     * appropriate values if need be.\n     */\n    // ID of device containing file\n    this.dev = 0;\n    // inode number\n    this.ino = 0;\n    // device ID (if special file)\n    this.rdev = 0;\n    // number of hard links\n    this.nlink = 1;\n    // blocksize for file system I/O\n    this.blksize = 4096;\n    // @todo Maybe support these? atm, it's a one-user filesystem.\n    // user ID of owner\n    this.uid = 0;\n    // group ID of owner\n    this.gid = 0;\n    // XXX: Some file systems stash data on stats objects.\n    this.fileData = null;\n    this.size = size;\n    var currentTime = 0;\n    if (typeof (atimeMs) !== 'number') {\n        currentTime = Date.now();\n        atimeMs = currentTime;\n    }\n    if (typeof (mtimeMs) !== 'number') {\n        if (!currentTime) {\n            currentTime = Date.now();\n        }\n        mtimeMs = currentTime;\n    }\n    if (typeof (ctimeMs) !== 'number') {\n        if (!currentTime) {\n            currentTime = Date.now();\n        }\n        ctimeMs = currentTime;\n    }\n    if (typeof (birthtimeMs) !== 'number') {\n        if (!currentTime) {\n            currentTime = Date.now();\n        }\n        birthtimeMs = currentTime;\n    }\n    this.atimeMs = atimeMs;\n    this.ctimeMs = ctimeMs;\n    this.mtimeMs = mtimeMs;\n    this.birthtimeMs = birthtimeMs;\n    if (!mode) {\n        switch (itemType) {\n            case FileType.FILE:\n                this.mode = 0x1a4;\n                break;\n            case FileType.DIRECTORY:\n            default:\n                this.mode = 0x1ff;\n        }\n    }\n    else {\n        this.mode = mode;\n    }\n    // number of 512B blocks allocated\n    this.blocks = Math.ceil(size / 512);\n    // Check if mode also includes top-most bits, which indicate the file's\n    // type.\n    if (this.mode < 0x1000) {\n        this.mode |= itemType;\n    }\n};\n\nvar prototypeAccessors = { atime: { configurable: true },mtime: { configurable: true },ctime: { configurable: true },birthtime: { configurable: true } };\nStats.fromBuffer = function fromBuffer (buffer$$1) {\n    var size = buffer$$1.readUInt32LE(0), mode = buffer$$1.readUInt32LE(4), atime = buffer$$1.readDoubleLE(8), mtime = buffer$$1.readDoubleLE(16), ctime = buffer$$1.readDoubleLE(24);\n    return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\n};\n/**\n * Clones the stats object.\n */\nStats.clone = function clone (s) {\n    return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\n};\nprototypeAccessors.atime.get = function () {\n    return new Date(this.atimeMs);\n};\nprototypeAccessors.mtime.get = function () {\n    return new Date(this.mtimeMs);\n};\nprototypeAccessors.ctime.get = function () {\n    return new Date(this.ctimeMs);\n};\nprototypeAccessors.birthtime.get = function () {\n    return new Date(this.birthtimeMs);\n};\nStats.prototype.toBuffer = function toBuffer () {\n    var buffer$$1 = Buffer.alloc(32);\n    buffer$$1.writeUInt32LE(this.size, 0);\n    buffer$$1.writeUInt32LE(this.mode, 4);\n    buffer$$1.writeDoubleLE(this.atime.getTime(), 8);\n    buffer$$1.writeDoubleLE(this.mtime.getTime(), 16);\n    buffer$$1.writeDoubleLE(this.ctime.getTime(), 24);\n    return buffer$$1;\n};\n/**\n * @return [Boolean] True if this item is a file.\n */\nStats.prototype.isFile = function isFile () {\n    return (this.mode & 0xF000) === FileType.FILE;\n};\n/**\n * @return [Boolean] True if this item is a directory.\n */\nStats.prototype.isDirectory = function isDirectory () {\n    return (this.mode & 0xF000) === FileType.DIRECTORY;\n};\n/**\n * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\n */\nStats.prototype.isSymbolicLink = function isSymbolicLink () {\n    return (this.mode & 0xF000) === FileType.SYMLINK;\n};\n/**\n * Change the mode of the file. We use this helper function to prevent messing\n * up the type of the file, which is encoded in mode.\n */\nStats.prototype.chmod = function chmod (mode) {\n    this.mode = (this.mode & 0xF000) | mode;\n};\n// We don't support the following types of files.\nStats.prototype.isSocket = function isSocket () {\n    return false;\n};\nStats.prototype.isBlockDevice = function isBlockDevice () {\n    return false;\n};\nStats.prototype.isCharacterDevice = function isCharacterDevice () {\n    return false;\n};\nStats.prototype.isFIFO = function isFIFO () {\n    return false;\n};\n\nObject.defineProperties( Stats.prototype, prototypeAccessors );\n\n/**\n * @hidden\n */\nvar toExport = typeof (window) !== 'undefined' ? window : typeof (self) !== 'undefined' ? self : global;\n\n/**\n * @hidden\n */\nvar bfsSetImmediate;\nif (typeof (setImmediate) !== \"undefined\") {\n    bfsSetImmediate = setImmediate;\n}\nelse {\n    var gScope = toExport;\n    var timeouts = [];\n    var messageName = \"zero-timeout-message\";\n    var canUsePostMessage = function () {\n        if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {\n            return false;\n        }\n        var postMessageIsAsync = true;\n        var oldOnMessage = gScope.onmessage;\n        gScope.onmessage = function () {\n            postMessageIsAsync = false;\n        };\n        gScope.postMessage('', '*');\n        gScope.onmessage = oldOnMessage;\n        return postMessageIsAsync;\n    };\n    if (canUsePostMessage()) {\n        bfsSetImmediate = function (fn) {\n            timeouts.push(fn);\n            gScope.postMessage(messageName, \"*\");\n        };\n        var handleMessage = function (event) {\n            if (event.source === self && event.data === messageName) {\n                if (event.stopPropagation) {\n                    event.stopPropagation();\n                }\n                else {\n                    event.cancelBubble = true;\n                }\n                if (timeouts.length > 0) {\n                    var fn = timeouts.shift();\n                    return fn();\n                }\n            }\n        };\n        if (gScope.addEventListener) {\n            gScope.addEventListener('message', handleMessage, true);\n        }\n        else {\n            gScope.attachEvent('onmessage', handleMessage);\n        }\n    }\n    else if (gScope.MessageChannel) {\n        // WebWorker MessageChannel\n        var channel = new gScope.MessageChannel();\n        channel.port1.onmessage = function (event) {\n            if (timeouts.length > 0) {\n                return timeouts.shift()();\n            }\n        };\n        bfsSetImmediate = function (fn) {\n            timeouts.push(fn);\n            channel.port2.postMessage('');\n        };\n    }\n    else {\n        bfsSetImmediate = function (fn) {\n            return setTimeout(fn, 0);\n        };\n    }\n}\nvar setImmediate$1 = bfsSetImmediate;\n\n/** Used for unit testing. Defaults to a NOP. */\nvar wrapCbHook = function (cb, numArgs) {\n    return cb;\n};\n/**\n * Wraps a callback function, ensuring it is invoked through setImmediate.\n * @hidden\n */\nfunction wrapCb(cb, numArgs) {\n    if (typeof cb !== 'function') {\n        throw new Error('Callback must be a function.');\n    }\n    var hookedCb = wrapCbHook(cb, numArgs);\n    // We could use `arguments`, but Function.call/apply is expensive. And we only\n    // need to handle 1-3 arguments\n    switch (numArgs) {\n        case 1:\n            return function (arg1) {\n                setImmediate$1(function () {\n                    return hookedCb(arg1);\n                });\n            };\n        case 2:\n            return function (arg1, arg2) {\n                setImmediate$1(function () {\n                    return hookedCb(arg1, arg2);\n                });\n            };\n        case 3:\n            return function (arg1, arg2, arg3) {\n                setImmediate$1(function () {\n                    return hookedCb(arg1, arg2, arg3);\n                });\n            };\n        default:\n            throw new Error('Invalid invocation of wrapCb.');\n    }\n}\n/**\n * @hidden\n */\nfunction assertRoot(fs) {\n    if (fs) {\n        return fs;\n    }\n    throw new ApiError(ErrorCode.EIO, \"Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)\");\n}\n/**\n * @hidden\n */\nfunction normalizeMode(mode, def) {\n    switch (typeof mode) {\n        case 'number':\n            // (path, flag, mode, cb?)\n            return mode;\n        case 'string':\n            // (path, flag, modeString, cb?)\n            var trueMode = parseInt(mode, 8);\n            if (!isNaN(trueMode)) {\n                return trueMode;\n            }\n            // Invalid string.\n            return def;\n        default:\n            return def;\n    }\n}\n/**\n * @hidden\n */\nfunction normalizeTime(time) {\n    if (time instanceof Date) {\n        return time;\n    }\n    else if (typeof time === 'number') {\n        return new Date(time * 1000);\n    }\n    else {\n        throw new ApiError(ErrorCode.EINVAL, \"Invalid time.\");\n    }\n}\n/**\n * @hidden\n */\nfunction normalizePath(p) {\n    // Node doesn't allow null characters in paths.\n    if (p.indexOf('\\u0000') >= 0) {\n        throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');\n    }\n    else if (p === '') {\n        throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');\n    }\n    return path.resolve(p);\n}\n/**\n * @hidden\n */\nfunction normalizeOptions(options, defEnc, defFlag, defMode) {\n    // typeof null === 'object' so special-case handing is needed.\n    switch (options === null ? 'null' : typeof options) {\n        case 'object':\n            return {\n                encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                mode: normalizeMode(options['mode'], defMode)\n            };\n        case 'string':\n            return {\n                encoding: options,\n                flag: defFlag,\n                mode: defMode\n            };\n        case 'null':\n        case 'undefined':\n        case 'function':\n            return {\n                encoding: defEnc,\n                flag: defFlag,\n                mode: defMode\n            };\n        default:\n            throw new TypeError((\"\\\"options\\\" must be a string or an object, got \" + (typeof options) + \" instead.\"));\n    }\n}\n/**\n * The default callback is a NOP.\n * @hidden\n * @private\n */\nfunction nopCb() {\n    // NOP.\n}\n/**\n * The node frontend to all filesystems.\n * This layer handles:\n *\n * * Sanity checking inputs.\n * * Normalizing paths.\n * * Resetting stack depth for asynchronous operations which may not go through\n *   the browser by wrapping all input callbacks using `setImmediate`.\n * * Performing the requested operation through the filesystem or the file\n *   descriptor, as appropriate.\n * * Handling optional arguments and setting default arguments.\n * @see http://nodejs.org/api/fs.html\n */\nvar FS = function FS() {\n    /* tslint:enable:variable-name */\n    this.F_OK = 0;\n    this.R_OK = 4;\n    this.W_OK = 2;\n    this.X_OK = 1;\n    this.root = null;\n    this.fdMap = {};\n    this.nextFd = 100;\n};\nFS.prototype.initialize = function initialize (rootFS) {\n    if (!rootFS.constructor.isAvailable()) {\n        throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\n    }\n    return this.root = rootFS;\n};\n/**\n * converts Date or number to a fractional UNIX timestamp\n * Grabbed from NodeJS sources (lib/fs.js)\n */\nFS.prototype._toUnixTimestamp = function _toUnixTimestamp (time) {\n    if (typeof time === 'number') {\n        return time;\n    }\n    else if (time instanceof Date) {\n        return time.getTime() / 1000;\n    }\n    throw new Error(\"Cannot parse time: \" + time);\n};\n/**\n * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n *   not been initialized.\n */\nFS.prototype.getRootFS = function getRootFS () {\n    if (this.root) {\n        return this.root;\n    }\n    else {\n        return null;\n    }\n};\n// FILE OR DIRECTORY METHODS\n/**\n * Asynchronous rename. No arguments other than a possible exception are given\n * to the completion callback.\n * @param oldPath\n * @param newPath\n * @param callback\n */\nFS.prototype.rename = function rename (oldPath, newPath, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous rename.\n * @param oldPath\n * @param newPath\n */\nFS.prototype.renameSync = function renameSync (oldPath, newPath) {\n    assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\n};\n/**\n * Test whether or not the given path exists by checking with the file system.\n * Then call the callback argument with either true or false.\n * @example Sample invocation\n *   fs.exists('/etc/passwd', function (exists) {\n * util.debug(exists ? \"it's there\" : \"no passwd!\");\n *   });\n * @param path\n * @param callback\n */\nFS.prototype.exists = function exists (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        return assertRoot(this.root).exists(normalizePath(path$$1), newCb);\n    }\n    catch (e) {\n        // Doesn't return an error. If something bad happens, we assume it just\n        // doesn't exist.\n        return newCb(false);\n    }\n};\n/**\n * Test whether or not the given path exists by checking with the file system.\n * @param path\n * @return [boolean]\n */\nFS.prototype.existsSync = function existsSync (path$$1) {\n    try {\n        return assertRoot(this.root).existsSync(normalizePath(path$$1));\n    }\n    catch (e) {\n        // Doesn't return an error. If something bad happens, we assume it just\n        // doesn't exist.\n        return false;\n    }\n};\n/**\n * Asynchronous `stat`.\n * @param path\n * @param callback\n */\nFS.prototype.stat = function stat (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 2);\n    try {\n        return assertRoot(this.root).stat(normalizePath(path$$1), false, newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\n/**\n * Synchronous `stat`.\n * @param path\n * @return [BrowserFS.node.fs.Stats]\n */\nFS.prototype.statSync = function statSync (path$$1) {\n    return assertRoot(this.root).statSync(normalizePath(path$$1), false);\n};\n/**\n * Asynchronous `lstat`.\n * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n * then the link itself is stat-ed, not the file that it refers to.\n * @param path\n * @param callback\n */\nFS.prototype.lstat = function lstat (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 2);\n    try {\n        return assertRoot(this.root).stat(normalizePath(path$$1), true, newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\n/**\n * Synchronous `lstat`.\n * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n * then the link itself is stat-ed, not the file that it refers to.\n * @param path\n * @return [BrowserFS.node.fs.Stats]\n */\nFS.prototype.lstatSync = function lstatSync (path$$1) {\n    return assertRoot(this.root).statSync(normalizePath(path$$1), true);\n};\nFS.prototype.truncate = function truncate (path$$1, arg2, cb) {\n        if ( arg2 === void 0 ) arg2 = 0;\n        if ( cb === void 0 ) cb = nopCb;\n\n    var len = 0;\n    if (typeof arg2 === 'function') {\n        cb = arg2;\n    }\n    else if (typeof arg2 === 'number') {\n        len = arg2;\n    }\n    var newCb = wrapCb(cb, 1);\n    try {\n        if (len < 0) {\n            throw new ApiError(ErrorCode.EINVAL);\n        }\n        return assertRoot(this.root).truncate(normalizePath(path$$1), len, newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\n/**\n * Synchronous `truncate`.\n * @param path\n * @param len\n */\nFS.prototype.truncateSync = function truncateSync (path$$1, len) {\n        if ( len === void 0 ) len = 0;\n\n    if (len < 0) {\n        throw new ApiError(ErrorCode.EINVAL);\n    }\n    return assertRoot(this.root).truncateSync(normalizePath(path$$1), len);\n};\n/**\n * Asynchronous `unlink`.\n * @param path\n * @param callback\n */\nFS.prototype.unlink = function unlink (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        return assertRoot(this.root).unlink(normalizePath(path$$1), newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\n/**\n * Synchronous `unlink`.\n * @param path\n */\nFS.prototype.unlinkSync = function unlinkSync (path$$1) {\n    return assertRoot(this.root).unlinkSync(normalizePath(path$$1));\n};\nFS.prototype.open = function open (path$$1, flag, arg2, cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = nopCb;\n\n    var mode = normalizeMode(arg2, 0x1a4);\n    cb = typeof arg2 === 'function' ? arg2 : cb;\n    var newCb = wrapCb(cb, 2);\n    try {\n        assertRoot(this.root).open(normalizePath(path$$1), FileFlag.getFileFlag(flag), mode, function (e, file) {\n            if (file) {\n                newCb(e, this$1.getFdForFile(file));\n            }\n            else {\n                newCb(e);\n            }\n        });\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous file open.\n * @see http://www.manpagez.com/man/2/open/\n * @param path\n * @param flags\n * @param mode defaults to `0644`\n * @return [BrowserFS.File]\n */\nFS.prototype.openSync = function openSync (path$$1, flag, mode) {\n        if ( mode === void 0 ) mode = 0x1a4;\n\n    return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path$$1), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\n};\nFS.prototype.readFile = function readFile (filename, arg2, cb) {\n        if ( arg2 === void 0 ) arg2 = {};\n        if ( cb === void 0 ) cb = nopCb;\n\n    var options = normalizeOptions(arg2, null, 'r', null);\n    cb = typeof arg2 === 'function' ? arg2 : cb;\n    var newCb = wrapCb(cb, 2);\n    try {\n        var flag = FileFlag.getFileFlag(options['flag']);\n        if (!flag.isReadable()) {\n            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));\n        }\n        return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\nFS.prototype.readFileSync = function readFileSync (filename, arg2) {\n        if ( arg2 === void 0 ) arg2 = {};\n\n    var options = normalizeOptions(arg2, null, 'r', null);\n    var flag = FileFlag.getFileFlag(options.flag);\n    if (!flag.isReadable()) {\n        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');\n    }\n    return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\n};\nFS.prototype.writeFile = function writeFile (filename, data, arg3, cb) {\n        if ( arg3 === void 0 ) arg3 = {};\n        if ( cb === void 0 ) cb = nopCb;\n\n    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n    cb = typeof arg3 === 'function' ? arg3 : cb;\n    var newCb = wrapCb(cb, 1);\n    try {\n        var flag = FileFlag.getFileFlag(options.flag);\n        if (!flag.isWriteable()) {\n            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));\n        }\n        return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n    }\n    catch (e) {\n        return newCb(e);\n    }\n};\nFS.prototype.writeFileSync = function writeFileSync (filename, data, arg3) {\n    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n    var flag = FileFlag.getFileFlag(options.flag);\n    if (!flag.isWriteable()) {\n        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');\n    }\n    return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n};\nFS.prototype.appendFile = function appendFile (filename, data, arg3, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n    cb = typeof arg3 === 'function' ? arg3 : cb;\n    var newCb = wrapCb(cb, 1);\n    try {\n        var flag = FileFlag.getFileFlag(options.flag);\n        if (!flag.isAppendable()) {\n            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));\n        }\n        assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\nFS.prototype.appendFileSync = function appendFileSync (filename, data, arg3) {\n    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n    var flag = FileFlag.getFileFlag(options.flag);\n    if (!flag.isAppendable()) {\n        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');\n    }\n    return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n};\n// FILE DESCRIPTOR METHODS\n/**\n * Asynchronous `fstat`.\n * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n * specified by the file descriptor `fd`.\n * @param fd\n * @param callback\n */\nFS.prototype.fstat = function fstat (fd, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 2);\n    try {\n        var file = this.fd2file(fd);\n        file.stat(newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `fstat`.\n * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n * specified by the file descriptor `fd`.\n * @param fd\n * @return [BrowserFS.node.fs.Stats]\n */\nFS.prototype.fstatSync = function fstatSync (fd) {\n    return this.fd2file(fd).statSync();\n};\n/**\n * Asynchronous close.\n * @param fd\n * @param callback\n */\nFS.prototype.close = function close (fd, cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        this.fd2file(fd).close(function (e) {\n            if (!e) {\n                this$1.closeFd(fd);\n            }\n            newCb(e);\n        });\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous close.\n * @param fd\n */\nFS.prototype.closeSync = function closeSync (fd) {\n    this.fd2file(fd).closeSync();\n    this.closeFd(fd);\n};\nFS.prototype.ftruncate = function ftruncate (fd, arg2, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var length = typeof arg2 === 'number' ? arg2 : 0;\n    cb = typeof arg2 === 'function' ? arg2 : cb;\n    var newCb = wrapCb(cb, 1);\n    try {\n        var file = this.fd2file(fd);\n        if (length < 0) {\n            throw new ApiError(ErrorCode.EINVAL);\n        }\n        file.truncate(length, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous ftruncate.\n * @param fd\n * @param len\n */\nFS.prototype.ftruncateSync = function ftruncateSync (fd, len) {\n        if ( len === void 0 ) len = 0;\n\n    var file = this.fd2file(fd);\n    if (len < 0) {\n        throw new ApiError(ErrorCode.EINVAL);\n    }\n    file.truncateSync(len);\n};\n/**\n * Asynchronous fsync.\n * @param fd\n * @param callback\n */\nFS.prototype.fsync = function fsync (fd, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        this.fd2file(fd).sync(newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous fsync.\n * @param fd\n */\nFS.prototype.fsyncSync = function fsyncSync (fd) {\n    this.fd2file(fd).syncSync();\n};\n/**\n * Asynchronous fdatasync.\n * @param fd\n * @param callback\n */\nFS.prototype.fdatasync = function fdatasync (fd, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        this.fd2file(fd).datasync(newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous fdatasync.\n * @param fd\n */\nFS.prototype.fdatasyncSync = function fdatasyncSync (fd) {\n    this.fd2file(fd).datasyncSync();\n};\nFS.prototype.write = function write (fd, arg2, arg3, arg4, arg5, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var buffer$$1, offset, length, position = null;\n    if (typeof arg2 === 'string') {\n        // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n        var encoding = 'utf8';\n        switch (typeof arg3) {\n            case 'function':\n                // (fd, string, cb)\n                cb = arg3;\n                break;\n            case 'number':\n                // (fd, string, position, encoding?, cb?)\n                position = arg3;\n                encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                break;\n            default:\n                // ...try to find the callback and get out of here!\n                cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));\n        }\n        buffer$$1 = Buffer.from(arg2, encoding);\n        offset = 0;\n        length = buffer$$1.length;\n    }\n    else {\n        // Signature 2: (fd, buffer, offset, length, position?, cb?)\n        buffer$$1 = arg2;\n        offset = arg3;\n        length = arg4;\n        position = typeof arg5 === 'number' ? arg5 : null;\n        cb = typeof arg5 === 'function' ? arg5 : cb;\n    }\n    var newCb = wrapCb(cb, 3);\n    try {\n        var file = this.fd2file(fd);\n        if (position === undefined || position === null) {\n            position = file.getPos();\n        }\n        file.write(buffer$$1, offset, length, position, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\nFS.prototype.writeSync = function writeSync (fd, arg2, arg3, arg4, arg5) {\n    var buffer$$1, offset = 0, length, position;\n    if (typeof arg2 === 'string') {\n        // Signature 1: (fd, string, [position?, [encoding?]])\n        position = typeof arg3 === 'number' ? arg3 : null;\n        var encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n        offset = 0;\n        buffer$$1 = Buffer.from(arg2, encoding);\n        length = buffer$$1.length;\n    }\n    else {\n        // Signature 2: (fd, buffer, offset, length, position?)\n        buffer$$1 = arg2;\n        offset = arg3;\n        length = arg4;\n        position = typeof arg5 === 'number' ? arg5 : null;\n    }\n    var file = this.fd2file(fd);\n    if (position === undefined || position === null) {\n        position = file.getPos();\n    }\n    return file.writeSync(buffer$$1, offset, length, position);\n};\nFS.prototype.read = function read (fd, arg2, arg3, arg4, arg5, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var position, offset, length, buffer$$1, newCb;\n    if (typeof arg2 === 'number') {\n        // legacy interface\n        // (fd, length, position, encoding, callback)\n        length = arg2;\n        position = arg3;\n        var encoding = arg4;\n        cb = typeof arg5 === 'function' ? arg5 : cb;\n        offset = 0;\n        buffer$$1 = Buffer.alloc(length);\n        // XXX: Inefficient.\n        // Wrap the cb so we shelter upper layers of the API from these\n        // shenanigans.\n        newCb = wrapCb(function (err, bytesRead, buf) {\n            if (err) {\n                return cb(err);\n            }\n            cb(err, buf.toString(encoding), bytesRead);\n        }, 3);\n    }\n    else {\n        buffer$$1 = arg2;\n        offset = arg3;\n        length = arg4;\n        position = arg5;\n        newCb = wrapCb(cb, 3);\n    }\n    try {\n        var file = this.fd2file(fd);\n        if (position === undefined || position === null) {\n            position = file.getPos();\n        }\n        file.read(buffer$$1, offset, length, position, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\nFS.prototype.readSync = function readSync (fd, arg2, arg3, arg4, arg5) {\n    var shenanigans = false;\n    var buffer$$1, offset, length, position, encoding = 'utf8';\n    if (typeof arg2 === 'number') {\n        length = arg2;\n        position = arg3;\n        encoding = arg4;\n        offset = 0;\n        buffer$$1 = Buffer.alloc(length);\n        shenanigans = true;\n    }\n    else {\n        buffer$$1 = arg2;\n        offset = arg3;\n        length = arg4;\n        position = arg5;\n    }\n    var file = this.fd2file(fd);\n    if (position === undefined || position === null) {\n        position = file.getPos();\n    }\n    var rv = file.readSync(buffer$$1, offset, length, position);\n    if (!shenanigans) {\n        return rv;\n    }\n    else {\n        return [buffer$$1.toString(encoding), rv];\n    }\n};\n/**\n * Asynchronous `fchown`.\n * @param fd\n * @param uid\n * @param gid\n * @param callback\n */\nFS.prototype.fchown = function fchown (fd, uid, gid, callback) {\n        if ( callback === void 0 ) callback = nopCb;\n\n    var newCb = wrapCb(callback, 1);\n    try {\n        this.fd2file(fd).chown(uid, gid, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `fchown`.\n * @param fd\n * @param uid\n * @param gid\n */\nFS.prototype.fchownSync = function fchownSync (fd, uid, gid) {\n    this.fd2file(fd).chownSync(uid, gid);\n};\n/**\n * Asynchronous `fchmod`.\n * @param fd\n * @param mode\n * @param callback\n */\nFS.prototype.fchmod = function fchmod (fd, mode, cb) {\n    var newCb = wrapCb(cb, 1);\n    try {\n        var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n        this.fd2file(fd).chmod(numMode, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `fchmod`.\n * @param fd\n * @param mode\n */\nFS.prototype.fchmodSync = function fchmodSync (fd, mode) {\n    var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n    this.fd2file(fd).chmodSync(numMode);\n};\n/**\n * Change the file timestamps of a file referenced by the supplied file\n * descriptor.\n * @param fd\n * @param atime\n * @param mtime\n * @param callback\n */\nFS.prototype.futimes = function futimes (fd, atime, mtime, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        var file = this.fd2file(fd);\n        if (typeof atime === 'number') {\n            atime = new Date(atime * 1000);\n        }\n        if (typeof mtime === 'number') {\n            mtime = new Date(mtime * 1000);\n        }\n        file.utimes(atime, mtime, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Change the file timestamps of a file referenced by the supplied file\n * descriptor.\n * @param fd\n * @param atime\n * @param mtime\n */\nFS.prototype.futimesSync = function futimesSync (fd, atime, mtime) {\n    this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\n};\n// DIRECTORY-ONLY METHODS\n/**\n * Asynchronous `rmdir`.\n * @param path\n * @param callback\n */\nFS.prototype.rmdir = function rmdir (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).rmdir(path$$1, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `rmdir`.\n * @param path\n */\nFS.prototype.rmdirSync = function rmdirSync (path$$1) {\n    path$$1 = normalizePath(path$$1);\n    return assertRoot(this.root).rmdirSync(path$$1);\n};\n/**\n * Asynchronous `mkdir`.\n * @param path\n * @param mode defaults to `0777`\n * @param callback\n */\nFS.prototype.mkdir = function mkdir (path$$1, mode, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    if (typeof mode === 'function') {\n        cb = mode;\n        mode = 0x1ff;\n    }\n    var newCb = wrapCb(cb, 1);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).mkdir(path$$1, mode, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `mkdir`.\n * @param path\n * @param mode defaults to `0777`\n */\nFS.prototype.mkdirSync = function mkdirSync (path$$1, mode) {\n    assertRoot(this.root).mkdirSync(normalizePath(path$$1), normalizeMode(mode, 0x1ff));\n};\n/**\n * Asynchronous `readdir`. Reads the contents of a directory.\n * The callback gets two arguments `(err, files)` where `files` is an array of\n * the names of the files in the directory excluding `'.'` and `'..'`.\n * @param path\n * @param callback\n */\nFS.prototype.readdir = function readdir (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 2);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).readdir(path$$1, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `readdir`. Reads the contents of a directory.\n * @param path\n * @return [String[]]\n */\nFS.prototype.readdirSync = function readdirSync (path$$1) {\n    path$$1 = normalizePath(path$$1);\n    return assertRoot(this.root).readdirSync(path$$1);\n};\n// SYMLINK METHODS\n/**\n * Asynchronous `link`.\n * @param srcpath\n * @param dstpath\n * @param callback\n */\nFS.prototype.link = function link (srcpath, dstpath, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        srcpath = normalizePath(srcpath);\n        dstpath = normalizePath(dstpath);\n        assertRoot(this.root).link(srcpath, dstpath, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `link`.\n * @param srcpath\n * @param dstpath\n */\nFS.prototype.linkSync = function linkSync (srcpath, dstpath) {\n    srcpath = normalizePath(srcpath);\n    dstpath = normalizePath(dstpath);\n    return assertRoot(this.root).linkSync(srcpath, dstpath);\n};\nFS.prototype.symlink = function symlink (srcpath, dstpath, arg3, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var type = typeof arg3 === 'string' ? arg3 : 'file';\n    cb = typeof arg3 === 'function' ? arg3 : cb;\n    var newCb = wrapCb(cb, 1);\n    try {\n        if (type !== 'file' && type !== 'dir') {\n            return newCb(new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type));\n        }\n        srcpath = normalizePath(srcpath);\n        dstpath = normalizePath(dstpath);\n        assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `symlink`.\n * @param srcpath\n * @param dstpath\n * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n */\nFS.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {\n    if (!type) {\n        type = 'file';\n    }\n    else if (type !== 'file' && type !== 'dir') {\n        throw new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type);\n    }\n    srcpath = normalizePath(srcpath);\n    dstpath = normalizePath(dstpath);\n    return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\n};\n/**\n * Asynchronous readlink.\n * @param path\n * @param callback\n */\nFS.prototype.readlink = function readlink (path$$1, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 2);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).readlink(path$$1, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous readlink.\n * @param path\n * @return [String]\n */\nFS.prototype.readlinkSync = function readlinkSync (path$$1) {\n    path$$1 = normalizePath(path$$1);\n    return assertRoot(this.root).readlinkSync(path$$1);\n};\n// PROPERTY OPERATIONS\n/**\n * Asynchronous `chown`.\n * @param path\n * @param uid\n * @param gid\n * @param callback\n */\nFS.prototype.chown = function chown (path$$1, uid, gid, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).chown(path$$1, false, uid, gid, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `chown`.\n * @param path\n * @param uid\n * @param gid\n */\nFS.prototype.chownSync = function chownSync (path$$1, uid, gid) {\n    path$$1 = normalizePath(path$$1);\n    assertRoot(this.root).chownSync(path$$1, false, uid, gid);\n};\n/**\n * Asynchronous `lchown`.\n * @param path\n * @param uid\n * @param gid\n * @param callback\n */\nFS.prototype.lchown = function lchown (path$$1, uid, gid, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).chown(path$$1, true, uid, gid, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `lchown`.\n * @param path\n * @param uid\n * @param gid\n */\nFS.prototype.lchownSync = function lchownSync (path$$1, uid, gid) {\n    path$$1 = normalizePath(path$$1);\n    assertRoot(this.root).chownSync(path$$1, true, uid, gid);\n};\n/**\n * Asynchronous `chmod`.\n * @param path\n * @param mode\n * @param callback\n */\nFS.prototype.chmod = function chmod (path$$1, mode, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        var numMode = normalizeMode(mode, -1);\n        if (numMode < 0) {\n            throw new ApiError(ErrorCode.EINVAL, \"Invalid mode.\");\n        }\n        assertRoot(this.root).chmod(normalizePath(path$$1), false, numMode, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `chmod`.\n * @param path\n * @param mode\n */\nFS.prototype.chmodSync = function chmodSync (path$$1, mode) {\n    var numMode = normalizeMode(mode, -1);\n    if (numMode < 0) {\n        throw new ApiError(ErrorCode.EINVAL, \"Invalid mode.\");\n    }\n    path$$1 = normalizePath(path$$1);\n    assertRoot(this.root).chmodSync(path$$1, false, numMode);\n};\n/**\n * Asynchronous `lchmod`.\n * @param path\n * @param mode\n * @param callback\n */\nFS.prototype.lchmod = function lchmod (path$$1, mode, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        var numMode = normalizeMode(mode, -1);\n        if (numMode < 0) {\n            throw new ApiError(ErrorCode.EINVAL, \"Invalid mode.\");\n        }\n        assertRoot(this.root).chmod(normalizePath(path$$1), true, numMode, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `lchmod`.\n * @param path\n * @param mode\n */\nFS.prototype.lchmodSync = function lchmodSync (path$$1, mode) {\n    var numMode = normalizeMode(mode, -1);\n    if (numMode < 1) {\n        throw new ApiError(ErrorCode.EINVAL, \"Invalid mode.\");\n    }\n    assertRoot(this.root).chmodSync(normalizePath(path$$1), true, numMode);\n};\n/**\n * Change file timestamps of the file referenced by the supplied path.\n * @param path\n * @param atime\n * @param mtime\n * @param callback\n */\nFS.prototype.utimes = function utimes (path$$1, atime, mtime, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var newCb = wrapCb(cb, 1);\n    try {\n        assertRoot(this.root).utimes(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime), newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Change file timestamps of the file referenced by the supplied path.\n * @param path\n * @param atime\n * @param mtime\n */\nFS.prototype.utimesSync = function utimesSync (path$$1, atime, mtime) {\n    assertRoot(this.root).utimesSync(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime));\n};\nFS.prototype.realpath = function realpath (path$$1, arg2, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    var cache = typeof (arg2) === 'object' ? arg2 : {};\n    cb = typeof (arg2) === 'function' ? arg2 : nopCb;\n    var newCb = wrapCb(cb, 2);\n    try {\n        path$$1 = normalizePath(path$$1);\n        assertRoot(this.root).realpath(path$$1, cache, newCb);\n    }\n    catch (e) {\n        newCb(e);\n    }\n};\n/**\n * Synchronous `realpath`.\n * @param path\n * @param cache An object literal of mapped paths that can be used to\n *   force a specific path resolution or avoid additional `fs.stat` calls for\n *   known real paths.\n * @return [String]\n */\nFS.prototype.realpathSync = function realpathSync (path$$1, cache) {\n        if ( cache === void 0 ) cache = {};\n\n    path$$1 = normalizePath(path$$1);\n    return assertRoot(this.root).realpathSync(path$$1, cache);\n};\nFS.prototype.watchFile = function watchFile (filename, arg2, listener) {\n        if ( listener === void 0 ) listener = nopCb;\n\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.unwatchFile = function unwatchFile (filename, listener) {\n        if ( listener === void 0 ) listener = nopCb;\n\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.watch = function watch (filename, arg2, listener) {\n        if ( listener === void 0 ) listener = nopCb;\n\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.access = function access (path$$1, arg2, cb) {\n        if ( cb === void 0 ) cb = nopCb;\n\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.accessSync = function accessSync (path$$1, mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.createReadStream = function createReadStream (path$$1, options) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nFS.prototype.createWriteStream = function createWriteStream (path$$1, options) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n/**\n * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\n */\nFS.prototype.wrapCallbacks = function wrapCallbacks (cbWrapper) {\n    wrapCbHook = cbWrapper;\n};\nFS.prototype.getFdForFile = function getFdForFile (file) {\n    var fd = this.nextFd++;\n    this.fdMap[fd] = file;\n    return fd;\n};\nFS.prototype.fd2file = function fd2file (fd) {\n    var rv = this.fdMap[fd];\n    if (rv) {\n        return rv;\n    }\n    else {\n        throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');\n    }\n};\nFS.prototype.closeFd = function closeFd (fd) {\n    delete this.fdMap[fd];\n};\n/* tslint:disable:variable-name */\n// Exported fs.Stats.\nFS.Stats = Stats;\n\n// Manually export the individual public functions of fs.\n// Required because some code will invoke functions off of the module.\n// e.g.:\n// let writeFile = fs.writeFile;\n// writeFile(...)\n/**\n * @hidden\n */\nvar fs = new FS();\n/**\n * @hidden\n */\nvar _fsMock = {};\n/**\n * @hidden\n */\nvar fsProto = FS.prototype;\nObject.keys(fsProto).forEach(function (key) {\n    if (typeof fs[key] === 'function') {\n        _fsMock[key] = function () {\n            return fs[key].apply(fs, arguments);\n        };\n    }\n    else {\n        _fsMock[key] = fs[key];\n    }\n});\n_fsMock['changeFSModule'] = function (newFs) {\n    fs = newFs;\n};\n_fsMock['getFSModule'] = function () {\n    return fs;\n};\n_fsMock['FS'] = FS;\n_fsMock['Stats'] = FS.Stats;\n\n/*\n * Levenshtein distance, from the `js-levenshtein` NPM module.\n * Copied here to avoid complexity of adding another CommonJS module dependency.\n */\nfunction _min(d0, d1, d2, bx, ay) {\n    return d0 < d1 || d2 < d1\n        ? d0 > d2\n            ? d2 + 1\n            : d0 + 1\n        : bx === ay\n            ? d1\n            : d1 + 1;\n}\n/**\n * Calculates levenshtein distance.\n * @param a\n * @param b\n */\nfunction levenshtein(a, b) {\n    if (a === b) {\n        return 0;\n    }\n    if (a.length > b.length) {\n        var tmp = a;\n        a = b;\n        b = tmp;\n    }\n    var la = a.length;\n    var lb = b.length;\n    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {\n        la--;\n        lb--;\n    }\n    var offset = 0;\n    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {\n        offset++;\n    }\n    la -= offset;\n    lb -= offset;\n    if (la === 0 || lb === 1) {\n        return lb;\n    }\n    var vector = new Array(la << 1);\n    for (var y = 0; y < la;) {\n        vector[la + y] = a.charCodeAt(offset + y);\n        vector[y] = ++y;\n    }\n    var x;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    for (x = 0; (x + 3) < lb;) {\n        var bx0 = b.charCodeAt(offset + (d0 = x));\n        var bx1 = b.charCodeAt(offset + (d1 = x + 1));\n        var bx2 = b.charCodeAt(offset + (d2 = x + 2));\n        var bx3 = b.charCodeAt(offset + (d3 = x + 3));\n        var dd$1 = (x += 4);\n        for (var y$1 = 0; y$1 < la;) {\n            var ay = vector[la + y$1];\n            var dy = vector[y$1];\n            d0 = _min(dy, d0, d1, bx0, ay);\n            d1 = _min(d0, d1, d2, bx1, ay);\n            d2 = _min(d1, d2, d3, bx2, ay);\n            dd$1 = _min(d2, d3, dd$1, bx3, ay);\n            vector[y$1++] = dd$1;\n            d3 = d2;\n            d2 = d1;\n            d1 = d0;\n            d0 = dy;\n        }\n    }\n    var dd = 0;\n    for (; x < lb;) {\n        var bx0$1 = b.charCodeAt(offset + (d0 = x));\n        dd = ++x;\n        for (var y$2 = 0; y$2 < la; y$2++) {\n            var dy$1 = vector[y$2];\n            vector[y$2] = dd = dy$1 < d0 || dd < d0\n                ? dy$1 > dd ? dd + 1 : dy$1 + 1\n                : bx0$1 === vector[la + y$2]\n                    ? d0\n                    : d0 + 1;\n            d0 = dy$1;\n        }\n    }\n    return dd;\n}\n\nfunction deprecationMessage(print, fsName, opts) {\n    if (print) {\n        // tslint:disable-next-line:no-console\n        console.warn((\"[\" + fsName + \"] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '\" + fsName + \".Create(\" + (JSON.stringify(opts)) + \", callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.\"));\n        // tslint:enable-next-line:no-console\n    }\n}\n/**\n * Checks for any IE version, including IE11 which removed MSIE from the\n * userAgent string.\n * @hidden\n */\nvar isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\n/**\n * Check if we're in a web worker.\n * @hidden\n */\nvar isWebWorker = typeof window === \"undefined\";\n/**\n * Throws an exception. Called on code paths that should be impossible.\n * @hidden\n */\nfunction fail() {\n    throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\n}\n/**\n * Synchronous recursive makedir.\n * @hidden\n */\nfunction mkdirpSync(p, mode, fs) {\n    if (!fs.existsSync(p)) {\n        mkdirpSync(path.dirname(p), mode, fs);\n        fs.mkdirSync(p, mode);\n    }\n}\n/**\n * Converts a buffer into an array buffer. Attempts to do so in a\n * zero-copy manner, e.g. the array references the same memory.\n * @hidden\n */\nfunction buffer2ArrayBuffer(buff) {\n    var u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\n    if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\n        return u8.buffer;\n    }\n    else {\n        return u8.buffer.slice(u8offset, u8offset + u8Len);\n    }\n}\n/**\n * Converts a buffer into a Uint8Array. Attempts to do so in a\n * zero-copy manner, e.g. the array references the same memory.\n * @hidden\n */\nfunction buffer2Uint8array(buff) {\n    if (buff instanceof Uint8Array) {\n        // BFS & Node v4.0 buffers *are* Uint8Arrays.\n        return buff;\n    }\n    else {\n        // Uint8Arrays can be constructed from arrayish numbers.\n        // At this point, we assume this isn't a BFS array.\n        return new Uint8Array(buff);\n    }\n}\n/**\n * Converts the given arrayish object into a Buffer. Attempts to\n * be zero-copy.\n * @hidden\n */\nfunction arrayish2Buffer(arr) {\n    if (arr instanceof Buffer) {\n        return arr;\n    }\n    else if (arr instanceof Uint8Array) {\n        return uint8Array2Buffer(arr);\n    }\n    else {\n        return Buffer.from(arr);\n    }\n}\n/**\n * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\n * @hidden\n */\nfunction uint8Array2Buffer(u8) {\n    if (u8 instanceof Buffer) {\n        return u8;\n    }\n    else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\n        return arrayBuffer2Buffer(u8.buffer);\n    }\n    else {\n        return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\n    }\n}\n/**\n * Converts the given array buffer into a Buffer. Attempts to be\n * zero-copy.\n * @hidden\n */\nfunction arrayBuffer2Buffer(ab) {\n    return Buffer.from(ab);\n}\n/**\n * Copies a slice of the given buffer\n * @hidden\n */\nfunction copyingSlice(buff, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = buff.length;\n\n    if (start < 0 || end < 0 || end > buff.length || start > end) {\n        throw new TypeError((\"Invalid slice bounds on buffer of length \" + (buff.length) + \": [\" + start + \", \" + end + \"]\"));\n    }\n    if (buff.length === 0) {\n        // Avoid s0 corner case in ArrayBuffer case.\n        return emptyBuffer();\n    }\n    else {\n        var u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\n        buff[0] = newS0;\n        if (u8[0] === newS0) {\n            // Same memory. Revert & copy.\n            u8[0] = s0;\n            return uint8Array2Buffer(u8.slice(start, end));\n        }\n        else {\n            // Revert.\n            buff[0] = s0;\n            return uint8Array2Buffer(u8.subarray(start, end));\n        }\n    }\n}\n/**\n * @hidden\n */\nvar emptyBuff = null;\n/**\n * Returns an empty buffer.\n * @hidden\n */\nfunction emptyBuffer() {\n    if (emptyBuff) {\n        return emptyBuff;\n    }\n    return emptyBuff = Buffer.alloc(0);\n}\n/**\n * Option validator for a Buffer file system option.\n * @hidden\n */\nfunction bufferValidator(v, cb) {\n    if (Buffer.isBuffer(v)) {\n        cb();\n    }\n    else {\n        cb(new ApiError(ErrorCode.EINVAL, \"option must be a Buffer.\"));\n    }\n}\n/**\n * Checks that the given options object is valid for the file system options.\n * @hidden\n */\nfunction checkOptions(fsType, opts, cb) {\n    var optsInfo = fsType.Options;\n    var fsName = fsType.Name;\n    var pendingValidators = 0;\n    var callbackCalled = false;\n    var loopEnded = false;\n    function validatorCallback(e) {\n        if (!callbackCalled) {\n            if (e) {\n                callbackCalled = true;\n                cb(e);\n            }\n            pendingValidators--;\n            if (pendingValidators === 0 && loopEnded) {\n                cb();\n            }\n        }\n    }\n    // Check for required options.\n    var loop = function ( optName ) {\n        if (optsInfo.hasOwnProperty(optName)) {\n            var opt = optsInfo[optName];\n            var providedValue = opts[optName];\n            if (providedValue === undefined || providedValue === null) {\n                if (!opt.optional) {\n                    // Required option, not provided.\n                    // Any incorrect options provided? Which ones are close to the provided one?\n                    // (edit distance 5 === close)\n                    var incorrectOptions = Object.keys(opts).filter(function (o) { return !(o in optsInfo); }).map(function (a) {\n                        return { str: a, distance: levenshtein(optName, a) };\n                    }).filter(function (o) { return o.distance < 5; }).sort(function (a, b) { return a.distance - b.distance; });\n                    // Validators may be synchronous.\n                    if (callbackCalled) {\n                        return {};\n                    }\n                    callbackCalled = true;\n                    return { v: cb(new ApiError(ErrorCode.EINVAL, (\"[\" + fsName + \"] Required option '\" + optName + \"' not provided.\" + (incorrectOptions.length > 0 ? (\" You provided unrecognized option '\" + (incorrectOptions[0].str) + \"'; perhaps you meant to type '\" + optName + \"'.\") : '') + \"\\nOption description: \" + (opt.description)))) };\n                }\n                // Else: Optional option, not provided. That is OK.\n            }\n            else {\n                // Option provided! Check type.\n                var typeMatches = false;\n                if (Array.isArray(opt.type)) {\n                    typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\n                }\n                else {\n                    typeMatches = typeof (providedValue) === opt.type;\n                }\n                if (!typeMatches) {\n                    // Validators may be synchronous.\n                    if (callbackCalled) {\n                        return {};\n                    }\n                    callbackCalled = true;\n                    return { v: cb(new ApiError(ErrorCode.EINVAL, (\"[\" + fsName + \"] Value provided for option \" + optName + \" is not the proper type. Expected \" + (Array.isArray(opt.type) ? (\"one of {\" + (opt.type.join(\", \")) + \"}\") : opt.type) + \", but received \" + (typeof (providedValue)) + \"\\nOption description: \" + (opt.description)))) };\n                }\n                else if (opt.validator) {\n                    pendingValidators++;\n                    opt.validator(providedValue, validatorCallback);\n                }\n                // Otherwise: All good!\n            }\n        }\n    };\n\n    for (var optName in optsInfo) {\n        var returned = loop( optName );\n\n        if ( returned ) return returned.v;\n    }\n    loopEnded = true;\n    if (pendingValidators === 0 && !callbackCalled) {\n        cb();\n    }\n}\n\nvar BFSUtils = /*#__PURE__*/Object.freeze({\n    deprecationMessage: deprecationMessage,\n    isIE: isIE,\n    isWebWorker: isWebWorker,\n    fail: fail,\n    mkdirpSync: mkdirpSync,\n    buffer2ArrayBuffer: buffer2ArrayBuffer,\n    buffer2Uint8array: buffer2Uint8array,\n    arrayish2Buffer: arrayish2Buffer,\n    uint8Array2Buffer: uint8Array2Buffer,\n    arrayBuffer2Buffer: arrayBuffer2Buffer,\n    copyingSlice: copyingSlice,\n    emptyBuffer: emptyBuffer,\n    bufferValidator: bufferValidator,\n    checkOptions: checkOptions\n});\n\nvar BFSEmscriptenStreamOps = function BFSEmscriptenStreamOps(fs) {\n    this.fs = fs;\n    this.nodefs = fs.getNodeFS();\n    this.FS = fs.getFS();\n    this.PATH = fs.getPATH();\n    this.ERRNO_CODES = fs.getERRNO_CODES();\n};\nBFSEmscriptenStreamOps.prototype.open = function open (stream) {\n    var path$$1 = this.fs.realPath(stream.node);\n    var FS = this.FS;\n    try {\n        if (FS.isFile(stream.node.mode)) {\n            stream.nfd = this.nodefs.openSync(path$$1, this.fs.flagsToPermissionString(stream.flags));\n        }\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenStreamOps.prototype.close = function close (stream) {\n    var FS = this.FS;\n    try {\n        if (FS.isFile(stream.node.mode) && stream.nfd) {\n            this.nodefs.closeSync(stream.nfd);\n        }\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenStreamOps.prototype.read = function read (stream, buffer$$1, offset, length, position) {\n    // Avoid copying overhead by reading directly into buffer.\n    try {\n        return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);\n    }\n    catch (e) {\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenStreamOps.prototype.write = function write (stream, buffer$$1, offset, length, position) {\n    // Avoid copying overhead.\n    try {\n        return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);\n    }\n    catch (e) {\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenStreamOps.prototype.llseek = function llseek (stream, offset, whence) {\n    var position = offset;\n    if (whence === 1) { // SEEK_CUR.\n        position += stream.position;\n    }\n    else if (whence === 2) { // SEEK_END.\n        if (this.FS.isFile(stream.node.mode)) {\n            try {\n                var stat = this.nodefs.fstatSync(stream.nfd);\n                position += stat.size;\n            }\n            catch (e) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n    }\n    if (position < 0) {\n        throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n    }\n    stream.position = position;\n    return position;\n};\nvar BFSEmscriptenNodeOps = function BFSEmscriptenNodeOps(fs) {\n    this.fs = fs;\n    this.nodefs = fs.getNodeFS();\n    this.FS = fs.getFS();\n    this.PATH = fs.getPATH();\n    this.ERRNO_CODES = fs.getERRNO_CODES();\n};\nBFSEmscriptenNodeOps.prototype.getattr = function getattr (node) {\n    var path$$1 = this.fs.realPath(node);\n    var stat;\n    try {\n        stat = this.nodefs.lstatSync(path$$1);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n    return {\n        dev: stat.dev,\n        ino: stat.ino,\n        mode: stat.mode,\n        nlink: stat.nlink,\n        uid: stat.uid,\n        gid: stat.gid,\n        rdev: stat.rdev,\n        size: stat.size,\n        atime: stat.atime,\n        mtime: stat.mtime,\n        ctime: stat.ctime,\n        blksize: stat.blksize,\n        blocks: stat.blocks\n    };\n};\nBFSEmscriptenNodeOps.prototype.setattr = function setattr (node, attr) {\n    var path$$1 = this.fs.realPath(node);\n    try {\n        if (attr.mode !== undefined) {\n            this.nodefs.chmodSync(path$$1, attr.mode);\n            // update the common node structure mode as well\n            node.mode = attr.mode;\n        }\n        if (attr.timestamp !== undefined) {\n            var date = new Date(attr.timestamp);\n            this.nodefs.utimesSync(path$$1, date, date);\n        }\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        // Ignore not supported errors. Emscripten does utimesSync when it\n        // writes files, but never really requires the value to be set.\n        if (e.code !== \"ENOTSUP\") {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n        }\n    }\n    if (attr.size !== undefined) {\n        try {\n            this.nodefs.truncateSync(path$$1, attr.size);\n        }\n        catch (e) {\n            if (!e.code) {\n                throw e;\n            }\n            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n        }\n    }\n};\nBFSEmscriptenNodeOps.prototype.lookup = function lookup (parent, name) {\n    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);\n    var mode = this.fs.getMode(path$$1);\n    return this.fs.createNode(parent, name, mode);\n};\nBFSEmscriptenNodeOps.prototype.mknod = function mknod (parent, name, mode, dev) {\n    var node = this.fs.createNode(parent, name, mode, dev);\n    // create the backing node for this in the fs root as well\n    var path$$1 = this.fs.realPath(node);\n    try {\n        if (this.FS.isDir(node.mode)) {\n            this.nodefs.mkdirSync(path$$1, node.mode);\n        }\n        else {\n            this.nodefs.writeFileSync(path$$1, '', { mode: node.mode });\n        }\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n    return node;\n};\nBFSEmscriptenNodeOps.prototype.rename = function rename (oldNode, newDir, newName) {\n    var oldPath = this.fs.realPath(oldNode);\n    var newPath = this.PATH.join2(this.fs.realPath(newDir), newName);\n    try {\n        this.nodefs.renameSync(oldPath, newPath);\n        // This logic is missing from the original NodeFS,\n        // causing Emscripten's filesystem to think that the old file still exists.\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenNodeOps.prototype.unlink = function unlink (parent, name) {\n    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);\n    try {\n        this.nodefs.unlinkSync(path$$1);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenNodeOps.prototype.rmdir = function rmdir (parent, name) {\n    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);\n    try {\n        this.nodefs.rmdirSync(path$$1);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenNodeOps.prototype.readdir = function readdir (node) {\n    var path$$1 = this.fs.realPath(node);\n    try {\n        // Node does not list . and .. in directory listings,\n        // but Emscripten expects it.\n        var contents = this.nodefs.readdirSync(path$$1);\n        contents.push('.', '..');\n        return contents;\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenNodeOps.prototype.symlink = function symlink (parent, newName, oldPath) {\n    var newPath = this.PATH.join2(this.fs.realPath(parent), newName);\n    try {\n        this.nodefs.symlinkSync(oldPath, newPath);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nBFSEmscriptenNodeOps.prototype.readlink = function readlink (node) {\n    var path$$1 = this.fs.realPath(node);\n    try {\n        return this.nodefs.readlinkSync(path$$1);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n};\nvar BFSEmscriptenFS = function BFSEmscriptenFS(_FS, _PATH, _ERRNO_CODES, nodefs) {\n    if ( _FS === void 0 ) _FS = self['FS'];\n    if ( _PATH === void 0 ) _PATH = self['PATH'];\n    if ( _ERRNO_CODES === void 0 ) _ERRNO_CODES = self['ERRNO_CODES'];\n    if ( nodefs === void 0 ) nodefs = _fsMock;\n\n    // This maps the integer permission modes from http://linux.die.net/man/3/open\n    // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback\n    this.flagsToPermissionStringMap = {\n        0 /*O_RDONLY*/: 'r',\n        1 /*O_WRONLY*/: 'r+',\n        2 /*O_RDWR*/: 'r+',\n        64 /*O_CREAT*/: 'r',\n        65 /*O_WRONLY|O_CREAT*/: 'r+',\n        66 /*O_RDWR|O_CREAT*/: 'r+',\n        129 /*O_WRONLY|O_EXCL*/: 'rx+',\n        193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',\n        514 /*O_RDWR|O_TRUNC*/: 'w+',\n        577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',\n        578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',\n        705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',\n        706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',\n        1024 /*O_APPEND*/: 'a',\n        1025 /*O_WRONLY|O_APPEND*/: 'a',\n        1026 /*O_RDWR|O_APPEND*/: 'a+',\n        1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',\n        1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',\n        1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',\n        1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',\n        1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',\n        1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',\n        4096 /*O_RDONLY|O_DSYNC*/: 'rs',\n        4098 /*O_RDWR|O_DSYNC*/: 'rs+'\n    };\n    this.nodefs = nodefs;\n    this.FS = _FS;\n    this.PATH = _PATH;\n    this.ERRNO_CODES = _ERRNO_CODES;\n    this.node_ops = new BFSEmscriptenNodeOps(this);\n    this.stream_ops = new BFSEmscriptenStreamOps(this);\n};\nBFSEmscriptenFS.prototype.mount = function mount (m) {\n    return this.createNode(null, '/', this.getMode(m.opts.root), 0);\n};\nBFSEmscriptenFS.prototype.createNode = function createNode (parent, name, mode, dev) {\n    var FS = this.FS;\n    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n        throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n    }\n    var node = FS.createNode(parent, name, mode);\n    node.node_ops = this.node_ops;\n    node.stream_ops = this.stream_ops;\n    return node;\n};\nBFSEmscriptenFS.prototype.getMode = function getMode (path$$1) {\n    var stat;\n    try {\n        stat = this.nodefs.lstatSync(path$$1);\n    }\n    catch (e) {\n        if (!e.code) {\n            throw e;\n        }\n        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n    }\n    return stat.mode;\n};\nBFSEmscriptenFS.prototype.realPath = function realPath (node) {\n    var parts = [];\n    while (node.parent !== node) {\n        parts.push(node.name);\n        node = node.parent;\n    }\n    parts.push(node.mount.opts.root);\n    parts.reverse();\n    return this.PATH.join.apply(null, parts);\n};\nBFSEmscriptenFS.prototype.flagsToPermissionString = function flagsToPermissionString (flags) {\n    var parsedFlags = (typeof flags === \"string\") ? parseInt(flags, 10) : flags;\n    parsedFlags &= 0x1FFF;\n    if (parsedFlags in this.flagsToPermissionStringMap) {\n        return this.flagsToPermissionStringMap[parsedFlags];\n    }\n    else {\n        return flags;\n    }\n};\nBFSEmscriptenFS.prototype.getNodeFS = function getNodeFS () {\n    return this.nodefs;\n};\nBFSEmscriptenFS.prototype.getFS = function getFS () {\n    return this.FS;\n};\nBFSEmscriptenFS.prototype.getPATH = function getPATH () {\n    return this.PATH;\n};\nBFSEmscriptenFS.prototype.getERRNO_CODES = function getERRNO_CODES () {\n    return this.ERRNO_CODES;\n};\n\n/**\n * Basic filesystem class. Most filesystems should extend this class, as it\n * provides default implementations for a handful of methods.\n */\nvar BaseFileSystem = function BaseFileSystem () {};\n\nBaseFileSystem.prototype.supportsLinks = function supportsLinks () {\n    return false;\n};\nBaseFileSystem.prototype.diskSpace = function diskSpace (p, cb) {\n    cb(0, 0);\n};\n/**\n * Opens the file at path p with the given flag. The file must exist.\n * @param p The path to open.\n * @param flag The flag to use when opening the file.\n */\nBaseFileSystem.prototype.openFile = function openFile (p, flag, cb) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n/**\n * Create the file at path p with the given mode. Then, open it with the given\n * flag.\n */\nBaseFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.open = function open (p, flag, mode, cb) {\n        var this$1 = this;\n\n    var mustBeFile = function (e, stats) {\n        if (e) {\n            // File does not exist.\n            switch (flag.pathNotExistsAction()) {\n                case ActionType.CREATE_FILE:\n                    // Ensure parent exists.\n                    return this$1.stat(path.dirname(p), false, function (e, parentStats) {\n                        if (e) {\n                            cb(e);\n                        }\n                        else if (parentStats && !parentStats.isDirectory()) {\n                            cb(ApiError.ENOTDIR(path.dirname(p)));\n                        }\n                        else {\n                            this$1.createFile(p, flag, mode, cb);\n                        }\n                    });\n                case ActionType.THROW_EXCEPTION:\n                    return cb(ApiError.ENOENT(p));\n                default:\n                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n            }\n        }\n        else {\n            // File exists.\n            if (stats && stats.isDirectory()) {\n                return cb(ApiError.EISDIR(p));\n            }\n            switch (flag.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                    return cb(ApiError.EEXIST(p));\n                case ActionType.TRUNCATE_FILE:\n                    // NOTE: In a previous implementation, we deleted the file and\n                    // re-created it. However, this created a race condition if another\n                    // asynchronous request was trying to read the file, as the file\n                    // would not exist for a small period of time.\n                    return this$1.openFile(p, flag, function (e, fd) {\n                        if (e) {\n                            cb(e);\n                        }\n                        else if (fd) {\n                            fd.truncate(0, function () {\n                                fd.sync(function () {\n                                    cb(null, fd);\n                                });\n                            });\n                        }\n                        else {\n                            fail();\n                        }\n                    });\n                case ActionType.NOP:\n                    return this$1.openFile(p, flag, cb);\n                default:\n                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n            }\n        }\n    };\n    this.stat(p, false, mustBeFile);\n};\nBaseFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.stat = function stat (p, isLstat, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.statSync = function statSync (p, isLstat) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n/**\n * Opens the file at path p with the given flag. The file must exist.\n * @param p The path to open.\n * @param flag The flag to use when opening the file.\n * @return A File object corresponding to the opened file.\n */\nBaseFileSystem.prototype.openFileSync = function openFileSync (p, flag, mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n/**\n * Create the file at path p with the given mode. Then, open it with the given\n * flag.\n */\nBaseFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.openSync = function openSync (p, flag, mode) {\n    // Check if the path exists, and is a file.\n    var stats;\n    try {\n        stats = this.statSync(p, false);\n    }\n    catch (e) {\n        // File does not exist.\n        switch (flag.pathNotExistsAction()) {\n            case ActionType.CREATE_FILE:\n                // Ensure parent exists.\n                var parentStats = this.statSync(path.dirname(p), false);\n                if (!parentStats.isDirectory()) {\n                    throw ApiError.ENOTDIR(path.dirname(p));\n                }\n                return this.createFileSync(p, flag, mode);\n            case ActionType.THROW_EXCEPTION:\n                throw ApiError.ENOENT(p);\n            default:\n                throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n        }\n    }\n    // File exists.\n    if (stats.isDirectory()) {\n        throw ApiError.EISDIR(p);\n    }\n    switch (flag.pathExistsAction()) {\n        case ActionType.THROW_EXCEPTION:\n            throw ApiError.EEXIST(p);\n        case ActionType.TRUNCATE_FILE:\n            // Delete file.\n            this.unlinkSync(p);\n            // Create file. Use the same mode as the old file.\n            // Node itself modifies the ctime when this occurs, so this action\n            // will preserve that behavior if the underlying file system\n            // supports those properties.\n            return this.createFileSync(p, flag, stats.mode);\n        case ActionType.NOP:\n            return this.openFileSync(p, flag, mode);\n        default:\n            throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n    }\n};\nBaseFileSystem.prototype.unlink = function unlink (p, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.unlinkSync = function unlinkSync (p) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.rmdir = function rmdir (p, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.rmdirSync = function rmdirSync (p) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.readdir = function readdir (p, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.readdirSync = function readdirSync (p) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.exists = function exists (p, cb) {\n    this.stat(p, null, function (err) {\n        cb(!err);\n    });\n};\nBaseFileSystem.prototype.existsSync = function existsSync (p) {\n    try {\n        this.statSync(p, true);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nBaseFileSystem.prototype.realpath = function realpath (p, cache, cb) {\n    if (this.supportsLinks()) {\n        // The path could contain symlinks. Split up the path,\n        // resolve any symlinks, return the resolved string.\n        var splitPath = p.split(path.sep);\n        // TODO: Simpler to just pass through file, find sep and such.\n        for (var i = 0; i < splitPath.length; i++) {\n            var addPaths = splitPath.slice(0, i + 1);\n            splitPath[i] = path.join.apply(null, addPaths);\n        }\n    }\n    else {\n        // No symlinks. We just need to verify that it exists.\n        this.exists(p, function (doesExist) {\n            if (doesExist) {\n                cb(null, p);\n            }\n            else {\n                cb(ApiError.ENOENT(p));\n            }\n        });\n    }\n};\nBaseFileSystem.prototype.realpathSync = function realpathSync (p, cache) {\n    if (this.supportsLinks()) {\n        // The path could contain symlinks. Split up the path,\n        // resolve any symlinks, return the resolved string.\n        var splitPath = p.split(path.sep);\n        // TODO: Simpler to just pass through file, find sep and such.\n        for (var i = 0; i < splitPath.length; i++) {\n            var addPaths = splitPath.slice(0, i + 1);\n            splitPath[i] = path.join.apply(path, addPaths);\n        }\n        return splitPath.join(path.sep);\n    }\n    else {\n        // No symlinks. We just need to verify that it exists.\n        if (this.existsSync(p)) {\n            return p;\n        }\n        else {\n            throw ApiError.ENOENT(p);\n        }\n    }\n};\nBaseFileSystem.prototype.truncate = function truncate (p, len, cb) {\n    this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\n        if (er) {\n            return cb(er);\n        }\n        fd.truncate(len, (function (er) {\n            fd.close((function (er2) {\n                cb(er || er2);\n            }));\n        }));\n    }));\n};\nBaseFileSystem.prototype.truncateSync = function truncateSync (p, len) {\n    var fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n    // Need to safely close FD, regardless of whether or not truncate succeeds.\n    try {\n        fd.truncateSync(len);\n    }\n    catch (e) {\n        throw e;\n    }\n    finally {\n        fd.closeSync();\n    }\n};\nBaseFileSystem.prototype.readFile = function readFile (fname, encoding, flag, cb) {\n    // Wrap cb in file closing code.\n    var oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function (err, fd) {\n        if (err) {\n            return cb(err);\n        }\n        cb = function (err, arg) {\n            fd.close(function (err2) {\n                if (!err) {\n                    err = err2;\n                }\n                return oldCb(err, arg);\n            });\n        };\n        fd.stat(function (err, stat) {\n            if (err) {\n                return cb(err);\n            }\n            // Allocate buffer.\n            var buf = Buffer.alloc(stat.size);\n            fd.read(buf, 0, stat.size, 0, function (err) {\n                if (err) {\n                    return cb(err);\n                }\n                else if (encoding === null) {\n                    return cb(err, buf);\n                }\n                try {\n                    cb(null, buf.toString(encoding));\n                }\n                catch (e) {\n                    cb(e);\n                }\n            });\n        });\n    });\n};\nBaseFileSystem.prototype.readFileSync = function readFileSync (fname, encoding, flag) {\n    // Get file.\n    var fd = this.openSync(fname, flag, 0x1a4);\n    try {\n        var stat = fd.statSync();\n        // Allocate buffer.\n        var buf = Buffer.alloc(stat.size);\n        fd.readSync(buf, 0, stat.size, 0);\n        fd.closeSync();\n        if (encoding === null) {\n            return buf;\n        }\n        return buf.toString(encoding);\n    }\n    finally {\n        fd.closeSync();\n    }\n};\nBaseFileSystem.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {\n    // Wrap cb in file closing code.\n    var oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function (err, fd) {\n        if (err) {\n            return cb(err);\n        }\n        cb = function (err) {\n            fd.close(function (err2) {\n                oldCb(err ? err : err2);\n            });\n        };\n        try {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n        }\n        catch (e) {\n            return cb(e);\n        }\n        // Write into file.\n        fd.write(data, 0, data.length, 0, cb);\n    });\n};\nBaseFileSystem.prototype.writeFileSync = function writeFileSync (fname, data, encoding, flag, mode) {\n    // Get file.\n    var fd = this.openSync(fname, flag, mode);\n    try {\n        if (typeof data === 'string') {\n            data = Buffer.from(data, encoding);\n        }\n        // Write into file.\n        fd.writeSync(data, 0, data.length, 0);\n    }\n    finally {\n        fd.closeSync();\n    }\n};\nBaseFileSystem.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {\n    // Wrap cb in file closing code.\n    var oldCb = cb;\n    this.open(fname, flag, mode, function (err, fd) {\n        if (err) {\n            return cb(err);\n        }\n        cb = function (err) {\n            fd.close(function (err2) {\n                oldCb(err ? err : err2);\n            });\n        };\n        if (typeof data === 'string') {\n            data = Buffer.from(data, encoding);\n        }\n        fd.write(data, 0, data.length, null, cb);\n    });\n};\nBaseFileSystem.prototype.appendFileSync = function appendFileSync (fname, data, encoding, flag, mode) {\n    var fd = this.openSync(fname, flag, mode);\n    try {\n        if (typeof data === 'string') {\n            data = Buffer.from(data, encoding);\n        }\n        fd.writeSync(data, 0, data.length, null);\n    }\n    finally {\n        fd.closeSync();\n    }\n};\nBaseFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.utimesSync = function utimesSync (p, atime, mtime) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.link = function link (srcpath, dstpath, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.linkSync = function linkSync (srcpath, dstpath) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFileSystem.prototype.readlink = function readlink (p, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFileSystem.prototype.readlinkSync = function readlinkSync (p) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n/**\n * Implements the asynchronous API in terms of the synchronous API.\n * @class SynchronousFileSystem\n */\nvar SynchronousFileSystem = (function (BaseFileSystem) {\n    function SynchronousFileSystem () {\n        BaseFileSystem.apply(this, arguments);\n    }\n\n    if ( BaseFileSystem ) SynchronousFileSystem.__proto__ = BaseFileSystem;\n    SynchronousFileSystem.prototype = Object.create( BaseFileSystem && BaseFileSystem.prototype );\n    SynchronousFileSystem.prototype.constructor = SynchronousFileSystem;\n\n    SynchronousFileSystem.prototype.supportsSynch = function supportsSynch () {\n        return true;\n    };\n    SynchronousFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {\n        try {\n            this.renameSync(oldPath, newPath);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.stat = function stat (p, isLstat, cb) {\n        try {\n            cb(null, this.statSync(p, isLstat));\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.open = function open (p, flags, mode, cb) {\n        try {\n            cb(null, this.openSync(p, flags, mode));\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.unlink = function unlink (p, cb) {\n        try {\n            this.unlinkSync(p);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.rmdir = function rmdir (p, cb) {\n        try {\n            this.rmdirSync(p);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {\n        try {\n            this.mkdirSync(p, mode);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.readdir = function readdir (p, cb) {\n        try {\n            cb(null, this.readdirSync(p));\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {\n        try {\n            this.chmodSync(p, isLchmod, mode);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {\n        try {\n            this.chownSync(p, isLchown, uid, gid);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {\n        try {\n            this.utimesSync(p, atime, mtime);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.link = function link (srcpath, dstpath, cb) {\n        try {\n            this.linkSync(srcpath, dstpath);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {\n        try {\n            this.symlinkSync(srcpath, dstpath, type);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    SynchronousFileSystem.prototype.readlink = function readlink (p, cb) {\n        try {\n            cb(null, this.readlinkSync(p));\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n\n    return SynchronousFileSystem;\n}(BaseFileSystem));\n\n/**\n * Generic inode definition that can easily be serialized.\n */\nvar Inode = function Inode(id, size, mode, atime, mtime, ctime) {\n    this.id = id;\n    this.size = size;\n    this.mode = mode;\n    this.atime = atime;\n    this.mtime = mtime;\n    this.ctime = ctime;\n};\n/**\n * Converts the buffer into an Inode.\n */\nInode.fromBuffer = function fromBuffer (buffer$$1) {\n    if (buffer$$1 === undefined) {\n        throw new Error(\"NO\");\n    }\n    return new Inode(buffer$$1.toString('ascii', 30), buffer$$1.readUInt32LE(0), buffer$$1.readUInt16LE(4), buffer$$1.readDoubleLE(6), buffer$$1.readDoubleLE(14), buffer$$1.readDoubleLE(22));\n};\n/**\n * Handy function that converts the Inode to a Node Stats object.\n */\nInode.prototype.toStats = function toStats () {\n    return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\n};\n/**\n * Get the size of this Inode, in bytes.\n */\nInode.prototype.getSize = function getSize () {\n    // ASSUMPTION: ID is ASCII (1 byte per char).\n    return 30 + this.id.length;\n};\n/**\n * Writes the inode into the start of the buffer.\n */\nInode.prototype.toBuffer = function toBuffer (buff) {\n        if ( buff === void 0 ) buff = Buffer.alloc(this.getSize());\n\n    buff.writeUInt32LE(this.size, 0);\n    buff.writeUInt16LE(this.mode, 4);\n    buff.writeDoubleLE(this.atime, 6);\n    buff.writeDoubleLE(this.mtime, 14);\n    buff.writeDoubleLE(this.ctime, 22);\n    buff.write(this.id, 30, this.id.length, 'ascii');\n    return buff;\n};\n/**\n * Updates the Inode using information from the stats object. Used by file\n * systems at sync time, e.g.:\n * - Program opens file and gets a File object.\n * - Program mutates file. File object is responsible for maintaining\n *   metadata changes locally -- typically in a Stats object.\n * - Program closes file. File object's metadata changes are synced with the\n *   file system.\n * @return True if any changes have occurred.\n */\nInode.prototype.update = function update (stats) {\n    var hasChanged = false;\n    if (this.size !== stats.size) {\n        this.size = stats.size;\n        hasChanged = true;\n    }\n    if (this.mode !== stats.mode) {\n        this.mode = stats.mode;\n        hasChanged = true;\n    }\n    var atimeMs = stats.atime.getTime();\n    if (this.atime !== atimeMs) {\n        this.atime = atimeMs;\n        hasChanged = true;\n    }\n    var mtimeMs = stats.mtime.getTime();\n    if (this.mtime !== mtimeMs) {\n        this.mtime = mtimeMs;\n        hasChanged = true;\n    }\n    var ctimeMs = stats.ctime.getTime();\n    if (this.ctime !== ctimeMs) {\n        this.ctime = ctimeMs;\n        hasChanged = true;\n    }\n    return hasChanged;\n};\n// XXX: Copied from Stats. Should reconcile these two into something more\n//  compact.\n/**\n * @return [Boolean] True if this item is a file.\n */\nInode.prototype.isFile = function isFile () {\n    return (this.mode & 0xF000) === FileType.FILE;\n};\n/**\n * @return [Boolean] True if this item is a directory.\n */\nInode.prototype.isDirectory = function isDirectory () {\n    return (this.mode & 0xF000) === FileType.DIRECTORY;\n};\n\n/**\n * Base class that contains shared implementations of functions for the file\n * object.\n */\nvar BaseFile = function BaseFile () {};\n\nBaseFile.prototype.sync = function sync (cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFile.prototype.syncSync = function syncSync () {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFile.prototype.datasync = function datasync (cb) {\n    this.sync(cb);\n};\nBaseFile.prototype.datasyncSync = function datasyncSync () {\n    return this.syncSync();\n};\nBaseFile.prototype.chown = function chown (uid, gid, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFile.prototype.chownSync = function chownSync (uid, gid) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFile.prototype.chmod = function chmod (mode, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFile.prototype.chmodSync = function chmodSync (mode) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\nBaseFile.prototype.utimes = function utimes (atime, mtime, cb) {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n};\nBaseFile.prototype.utimesSync = function utimesSync (atime, mtime) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n};\n\n/**\n * An implementation of the File interface that operates on a file that is\n * completely in-memory. PreloadFiles are backed by a Buffer.\n *\n * This is also an abstract class, as it lacks an implementation of 'sync' and\n * 'close'. Each filesystem that wishes to use this file representation must\n * extend this class and implement those two methods.\n * @todo 'close' lever that disables functionality once closed.\n */\nvar PreloadFile = (function (BaseFile$$1) {\n    function PreloadFile(_fs, _path, _flag, _stat, contents) {\n        BaseFile$$1.call(this);\n        this._pos = 0;\n        this._dirty = false;\n        this._fs = _fs;\n        this._path = _path;\n        this._flag = _flag;\n        this._stat = _stat;\n        this._buffer = contents ? contents : emptyBuffer();\n        // Note: This invariant is *not* maintained once the file starts getting\n        // modified.\n        // Note: Only actually matters if file is readable, as writeable modes may\n        // truncate/append to file.\n        if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n            throw new Error((\"Invalid buffer: Buffer is \" + (this._buffer.length) + \" long, yet Stats object specifies that file is \" + (this._stat.size) + \" long.\"));\n        }\n    }\n\n    if ( BaseFile$$1 ) PreloadFile.__proto__ = BaseFile$$1;\n    PreloadFile.prototype = Object.create( BaseFile$$1 && BaseFile$$1.prototype );\n    PreloadFile.prototype.constructor = PreloadFile;\n    /**\n     * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n     */\n    PreloadFile.prototype.getBuffer = function getBuffer () {\n        return this._buffer;\n    };\n    /**\n     * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n     */\n    PreloadFile.prototype.getStats = function getStats () {\n        return this._stat;\n    };\n    PreloadFile.prototype.getFlag = function getFlag () {\n        return this._flag;\n    };\n    /**\n     * Get the path to this file.\n     * @return [String] The path to the file.\n     */\n    PreloadFile.prototype.getPath = function getPath () {\n        return this._path;\n    };\n    /**\n     * Get the current file position.\n     *\n     * We emulate the following bug mentioned in the Node documentation:\n     * > On Linux, positional writes don't work when the file is opened in append\n     *   mode. The kernel ignores the position argument and always appends the data\n     *   to the end of the file.\n     * @return [Number] The current file position.\n     */\n    PreloadFile.prototype.getPos = function getPos () {\n        if (this._flag.isAppendable()) {\n            return this._stat.size;\n        }\n        return this._pos;\n    };\n    /**\n     * Advance the current file position by the indicated number of positions.\n     * @param [Number] delta\n     */\n    PreloadFile.prototype.advancePos = function advancePos (delta) {\n        return this._pos += delta;\n    };\n    /**\n     * Set the file position.\n     * @param [Number] newPos\n     */\n    PreloadFile.prototype.setPos = function setPos (newPos) {\n        return this._pos = newPos;\n    };\n    /**\n     * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n     * class.\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    PreloadFile.prototype.sync = function sync (cb) {\n        try {\n            this.syncSync();\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * **Core**: Synchronous sync.\n     */\n    PreloadFile.prototype.syncSync = function syncSync () {\n        throw new ApiError(ErrorCode.ENOTSUP);\n    };\n    /**\n     * **Core**: Asynchronous close. Must be implemented by subclasses of this\n     * class.\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    PreloadFile.prototype.close = function close (cb) {\n        try {\n            this.closeSync();\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * **Core**: Synchronous close.\n     */\n    PreloadFile.prototype.closeSync = function closeSync () {\n        throw new ApiError(ErrorCode.ENOTSUP);\n    };\n    /**\n     * Asynchronous `stat`.\n     * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n     */\n    PreloadFile.prototype.stat = function stat (cb) {\n        try {\n            cb(null, Stats.clone(this._stat));\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * Synchronous `stat`.\n     */\n    PreloadFile.prototype.statSync = function statSync () {\n        return Stats.clone(this._stat);\n    };\n    /**\n     * Asynchronous truncate.\n     * @param [Number] len\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    PreloadFile.prototype.truncate = function truncate (len, cb) {\n        try {\n            this.truncateSync(len);\n            if (this._flag.isSynchronous() && !_fsMock.getRootFS().supportsSynch()) {\n                this.sync(cb);\n            }\n            cb();\n        }\n        catch (e) {\n            return cb(e);\n        }\n    };\n    /**\n     * Synchronous truncate.\n     * @param [Number] len\n     */\n    PreloadFile.prototype.truncateSync = function truncateSync (len) {\n        this._dirty = true;\n        if (!this._flag.isWriteable()) {\n            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n        }\n        this._stat.mtimeMs = Date.now();\n        if (len > this._buffer.length) {\n            var buf = Buffer.alloc(len - this._buffer.length, 0);\n            // Write will set @_stat.size for us.\n            this.writeSync(buf, 0, buf.length, this._buffer.length);\n            if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n            return;\n        }\n        this._stat.size = len;\n        // Truncate buffer to 'len'.\n        var newBuff = Buffer.alloc(len);\n        this._buffer.copy(newBuff, 0, 0, len);\n        this._buffer = newBuff;\n        if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {\n            this.syncSync();\n        }\n    };\n    /**\n     * Write buffer to the file.\n     * Note that it is unsafe to use fs.write multiple times on the same file\n     * without waiting for the callback.\n     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n     *  the file.\n     * @param [Number] offset Offset in the buffer to start reading data from.\n     * @param [Number] length The amount of bytes to write to the file.\n     * @param [Number] position Offset from the beginning of the file where this\n     *   data should be written. If position is null, the data will be written at\n     *   the current position.\n     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n     *   cb The number specifies the number of bytes written into the file.\n     */\n    PreloadFile.prototype.write = function write (buffer$$1, offset, length, position, cb) {\n        try {\n            cb(null, this.writeSync(buffer$$1, offset, length, position), buffer$$1);\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * Write buffer to the file.\n     * Note that it is unsafe to use fs.writeSync multiple times on the same file\n     * without waiting for the callback.\n     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n     *  the file.\n     * @param [Number] offset Offset in the buffer to start reading data from.\n     * @param [Number] length The amount of bytes to write to the file.\n     * @param [Number] position Offset from the beginning of the file where this\n     *   data should be written. If position is null, the data will be written at\n     *   the current position.\n     * @return [Number]\n     */\n    PreloadFile.prototype.writeSync = function writeSync (buffer$$1, offset, length, position) {\n        this._dirty = true;\n        if (position === undefined || position === null) {\n            position = this.getPos();\n        }\n        if (!this._flag.isWriteable()) {\n            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n        }\n        var endFp = position + length;\n        if (endFp > this._stat.size) {\n            this._stat.size = endFp;\n            if (endFp > this._buffer.length) {\n                // Extend the buffer!\n                var newBuff = Buffer.alloc(endFp);\n                this._buffer.copy(newBuff);\n                this._buffer = newBuff;\n            }\n        }\n        var len = buffer$$1.copy(this._buffer, position, offset, offset + length);\n        this._stat.mtimeMs = Date.now();\n        if (this._flag.isSynchronous()) {\n            this.syncSync();\n            return len;\n        }\n        this.setPos(position + len);\n        return len;\n    };\n    /**\n     * Read data from the file.\n     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n     *   written to.\n     * @param [Number] offset The offset within the buffer where writing will\n     *   start.\n     * @param [Number] length An integer specifying the number of bytes to read.\n     * @param [Number] position An integer specifying where to begin reading from\n     *   in the file. If position is null, data will be read from the current file\n     *   position.\n     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n     *   number is the number of bytes read\n     */\n    PreloadFile.prototype.read = function read (buffer$$1, offset, length, position, cb) {\n        try {\n            cb(null, this.readSync(buffer$$1, offset, length, position), buffer$$1);\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * Read data from the file.\n     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n     *   written to.\n     * @param [Number] offset The offset within the buffer where writing will\n     *   start.\n     * @param [Number] length An integer specifying the number of bytes to read.\n     * @param [Number] position An integer specifying where to begin reading from\n     *   in the file. If position is null, data will be read from the current file\n     *   position.\n     * @return [Number]\n     */\n    PreloadFile.prototype.readSync = function readSync (buffer$$1, offset, length, position) {\n        if (!this._flag.isReadable()) {\n            throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n        }\n        if (position === undefined || position === null) {\n            position = this.getPos();\n        }\n        var endRead = position + length;\n        if (endRead > this._stat.size) {\n            length = this._stat.size - position;\n        }\n        var rv = this._buffer.copy(buffer$$1, offset, position, position + length);\n        this._stat.atimeMs = Date.now();\n        this._pos = position + length;\n        return rv;\n    };\n    /**\n     * Asynchronous `fchmod`.\n     * @param [Number|String] mode\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    PreloadFile.prototype.chmod = function chmod (mode, cb) {\n        try {\n            this.chmodSync(mode);\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    };\n    /**\n     * Asynchronous `fchmod`.\n     * @param [Number] mode\n     */\n    PreloadFile.prototype.chmodSync = function chmodSync (mode) {\n        if (!this._fs.supportsProps()) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        this._dirty = true;\n        this._stat.chmod(mode);\n        this.syncSync();\n    };\n    PreloadFile.prototype.isDirty = function isDirty () {\n        return this._dirty;\n    };\n    /**\n     * Resets the dirty bit. Should only be called after a sync has completed successfully.\n     */\n    PreloadFile.prototype.resetDirty = function resetDirty () {\n        this._dirty = false;\n    };\n\n    return PreloadFile;\n}(BaseFile));\n/**\n * File class for the InMemory and XHR file systems.\n * Doesn't sync to anything, so it works nicely for memory-only files.\n */\nvar NoSyncFile = (function (PreloadFile) {\n    function NoSyncFile(_fs, _path, _flag, _stat, contents) {\n        PreloadFile.call(this, _fs, _path, _flag, _stat, contents);\n    }\n\n    if ( PreloadFile ) NoSyncFile.__proto__ = PreloadFile;\n    NoSyncFile.prototype = Object.create( PreloadFile && PreloadFile.prototype );\n    NoSyncFile.prototype.constructor = NoSyncFile;\n    /**\n     * Asynchronous sync. Doesn't do anything, simply calls the cb.\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    NoSyncFile.prototype.sync = function sync (cb) {\n        cb();\n    };\n    /**\n     * Synchronous sync. Doesn't do anything.\n     */\n    NoSyncFile.prototype.syncSync = function syncSync () {\n        // NOP.\n    };\n    /**\n     * Asynchronous close. Doesn't do anything, simply calls the cb.\n     * @param [Function(BrowserFS.ApiError)] cb\n     */\n    NoSyncFile.prototype.close = function close (cb) {\n        cb();\n    };\n    /**\n     * Synchronous close. Doesn't do anything.\n     */\n    NoSyncFile.prototype.closeSync = function closeSync () {\n        // NOP.\n    };\n\n    return NoSyncFile;\n}(PreloadFile));\n\n/**\n * @hidden\n */\nvar ROOT_NODE_ID = \"/\";\n/**\n * @hidden\n */\nvar emptyDirNode = null;\n/**\n * Returns an empty directory node.\n * @hidden\n */\nfunction getEmptyDirNode() {\n    if (emptyDirNode) {\n        return emptyDirNode;\n    }\n    return emptyDirNode = Buffer.from(\"{}\");\n}\n/**\n * Generates a random ID.\n * @hidden\n */\nfunction GenerateRandomID() {\n    // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0;\n        var v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n/**\n * Helper function. Checks if 'e' is defined. If so, it triggers the callback\n * with 'e' and returns false. Otherwise, returns true.\n * @hidden\n */\nfunction noError(e, cb) {\n    if (e) {\n        cb(e);\n        return false;\n    }\n    return true;\n}\n/**\n * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\n * triggers the callback with 'e', and returns false. Otherwise, returns true.\n * @hidden\n */\nfunction noErrorTx(e, tx, cb) {\n    if (e) {\n        tx.abort(function () {\n            cb(e);\n        });\n        return false;\n    }\n    return true;\n}\nvar LRUNode = function LRUNode(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n};\n// Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript\nvar LRUCache = function LRUCache(limit) {\n    this.limit = limit;\n    this.size = 0;\n    this.map = {};\n    this.head = null;\n    this.tail = null;\n};\n/**\n * Change or add a new value in the cache\n * We overwrite the entry if it already exists\n */\nLRUCache.prototype.set = function set (key, value) {\n    var node = new LRUNode(key, value);\n    if (this.map[key]) {\n        this.map[key].value = node.value;\n        this.remove(node.key);\n    }\n    else {\n        if (this.size >= this.limit) {\n            delete this.map[this.tail.key];\n            this.size--;\n            this.tail = this.tail.prev;\n            this.tail.next = null;\n        }\n    }\n    this.setHead(node);\n};\n/* Retrieve a single entry from the cache */\nLRUCache.prototype.get = function get (key) {\n    if (this.map[key]) {\n        var value = this.map[key].value;\n        var node = new LRUNode(key, value);\n        this.remove(key);\n        this.setHead(node);\n        return value;\n    }\n    else {\n        return null;\n    }\n};\n/* Remove a single entry from the cache */\nLRUCache.prototype.remove = function remove (key) {\n    var node = this.map[key];\n    if (!node) {\n        return;\n    }\n    if (node.prev !== null) {\n        node.prev.next = node.next;\n    }\n    else {\n        this.head = node.next;\n    }\n    if (node.next !== null) {\n        node.next.prev = node.prev;\n    }\n    else {\n        this.tail = node.prev;\n    }\n    delete this.map[key];\n    this.size--;\n};\n/* Resets the entire cache - Argument limit is optional to be reset */\nLRUCache.prototype.removeAll = function removeAll () {\n    this.size = 0;\n    this.map = {};\n    this.head = null;\n    this.tail = null;\n};\nLRUCache.prototype.setHead = function setHead (node) {\n    node.next = this.head;\n    node.prev = null;\n    if (this.head !== null) {\n        this.head.prev = node;\n    }\n    this.head = node;\n    if (this.tail === null) {\n        this.tail = node;\n    }\n    this.size++;\n    this.map[node.key] = node;\n};\n/**\n * A simple RW transaction for simple synchronous key-value stores.\n */\nvar SimpleSyncRWTransaction = function SimpleSyncRWTransaction(store) {\n    this.store = store;\n    /**\n     * Stores data in the keys we modify prior to modifying them.\n     * Allows us to roll back commits.\n     */\n    this.originalData = {};\n    /**\n     * List of keys modified in this transaction, if any.\n     */\n    this.modifiedKeys = [];\n};\nSimpleSyncRWTransaction.prototype.get = function get (key) {\n    var val = this.store.get(key);\n    this.stashOldValue(key, val);\n    return val;\n};\nSimpleSyncRWTransaction.prototype.put = function put (key, data, overwrite) {\n    this.markModified(key);\n    return this.store.put(key, data, overwrite);\n};\nSimpleSyncRWTransaction.prototype.del = function del (key) {\n    this.markModified(key);\n    this.store.del(key);\n};\nSimpleSyncRWTransaction.prototype.commit = function commit () { };\nSimpleSyncRWTransaction.prototype.abort = function abort () {\n        var this$1 = this;\n\n    // Rollback old values.\n    for (var i = 0, list = this$1.modifiedKeys; i < list.length; i += 1) {\n        var key = list[i];\n\n            var value = this$1.originalData[key];\n        if (!value) {\n            // Key didn't exist.\n            this$1.store.del(key);\n        }\n        else {\n            // Key existed. Store old value.\n            this$1.store.put(key, value, true);\n        }\n    }\n};\n/**\n * Stashes given key value pair into `originalData` if it doesn't already\n * exist. Allows us to stash values the program is requesting anyway to\n * prevent needless `get` requests if the program modifies the data later\n * on during the transaction.\n */\nSimpleSyncRWTransaction.prototype.stashOldValue = function stashOldValue (key, value) {\n    // Keep only the earliest value in the transaction.\n    if (!this.originalData.hasOwnProperty(key)) {\n        this.originalData[key] = value;\n    }\n};\n/**\n * Marks the given key as modified, and stashes its value if it has not been\n * stashed already.\n */\nSimpleSyncRWTransaction.prototype.markModified = function markModified (key) {\n    if (this.modifiedKeys.indexOf(key) === -1) {\n        this.modifiedKeys.push(key);\n        if (!this.originalData.hasOwnProperty(key)) {\n            this.originalData[key] = this.store.get(key);\n        }\n    }\n};\nvar SyncKeyValueFile = (function (PreloadFile$$1) {\n    function SyncKeyValueFile(_fs, _path, _flag, _stat, contents) {\n        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);\n    }\n\n    if ( PreloadFile$$1 ) SyncKeyValueFile.__proto__ = PreloadFile$$1;\n    SyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );\n    SyncKeyValueFile.prototype.constructor = SyncKeyValueFile;\n    SyncKeyValueFile.prototype.syncSync = function syncSync () {\n        if (this.isDirty()) {\n            this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());\n            this.resetDirty();\n        }\n    };\n    SyncKeyValueFile.prototype.closeSync = function closeSync () {\n        this.syncSync();\n    };\n\n    return SyncKeyValueFile;\n}(PreloadFile));\n/**\n * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\n * underlying key-value store.\n *\n * We use a unique ID for each node in the file system. The root node has a\n * fixed ID.\n * @todo Introduce Node ID caching.\n * @todo Check modes.\n */\nvar SyncKeyValueFileSystem = (function (SynchronousFileSystem$$1) {\n    function SyncKeyValueFileSystem(options) {\n        SynchronousFileSystem$$1.call(this);\n        this.store = options.store;\n        // INVARIANT: Ensure that the root exists.\n        this.makeRootDirectory();\n    }\n\n    if ( SynchronousFileSystem$$1 ) SyncKeyValueFileSystem.__proto__ = SynchronousFileSystem$$1;\n    SyncKeyValueFileSystem.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );\n    SyncKeyValueFileSystem.prototype.constructor = SyncKeyValueFileSystem;\n    SyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };\n\n    SyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };\n    SyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };\n    SyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };\n    SyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };\n    SyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return true; };\n    /**\n     * Delete all contents stored in the file system.\n     */\n    SyncKeyValueFileSystem.prototype.empty = function empty () {\n        this.store.clear();\n        // INVARIANT: Root always exists.\n        this.makeRootDirectory();\n    };\n    SyncKeyValueFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {\n        var tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), \n        // Remove oldPath from parent's directory listing.\n        oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\n        if (!oldDirList[oldName]) {\n            throw ApiError.ENOENT(oldPath);\n        }\n        var nodeId = oldDirList[oldName];\n        delete oldDirList[oldName];\n        // Invariant: Can't move a folder inside itself.\n        // This funny little hack ensures that the check passes only if oldPath\n        // is a subpath of newParent. We append '/' to avoid matching folders that\n        // are a substring of the bottom-most folder in the path.\n        if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n            throw new ApiError(ErrorCode.EBUSY, oldParent);\n        }\n        // Add newPath to parent's directory listing.\n        var newDirNode, newDirList;\n        if (newParent === oldParent) {\n            // Prevent us from re-grabbing the same directory listing, which still\n            // contains oldName.\n            newDirNode = oldDirNode;\n            newDirList = oldDirList;\n        }\n        else {\n            newDirNode = this.findINode(tx, newParent);\n            newDirList = this.getDirListing(tx, newParent, newDirNode);\n        }\n        if (newDirList[newName]) {\n            // If it's a file, delete it.\n            var newNameNode = this.getINode(tx, newPath, newDirList[newName]);\n            if (newNameNode.isFile()) {\n                try {\n                    tx.del(newNameNode.id);\n                    tx.del(newDirList[newName]);\n                }\n                catch (e) {\n                    tx.abort();\n                    throw e;\n                }\n            }\n            else {\n                // If it's a directory, throw a permissions error.\n                throw ApiError.EPERM(newPath);\n            }\n        }\n        newDirList[newName] = nodeId;\n        // Commit the two changed directory listings.\n        try {\n            tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\n            tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\n        }\n        catch (e) {\n            tx.abort();\n            throw e;\n        }\n        tx.commit();\n    };\n    SyncKeyValueFileSystem.prototype.statSync = function statSync (p, isLstat) {\n        // Get the inode to the item, convert it into a Stats object.\n        return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\n    };\n    SyncKeyValueFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {\n        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\n        // Open the file.\n        return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\n    };\n    SyncKeyValueFileSystem.prototype.openFileSync = function openFileSync (p, flag) {\n        var tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\n        if (data === undefined) {\n            throw ApiError.ENOENT(p);\n        }\n        return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\n    };\n    SyncKeyValueFileSystem.prototype.unlinkSync = function unlinkSync (p) {\n        this.removeEntry(p, false);\n    };\n    SyncKeyValueFileSystem.prototype.rmdirSync = function rmdirSync (p) {\n        // Check first if directory is empty.\n        if (this.readdirSync(p).length > 0) {\n            throw ApiError.ENOTEMPTY(p);\n        }\n        else {\n            this.removeEntry(p, true);\n        }\n    };\n    SyncKeyValueFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {\n        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\n    };\n    SyncKeyValueFileSystem.prototype.readdirSync = function readdirSync (p) {\n        var tx = this.store.beginTransaction('readonly');\n        return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\n    };\n    SyncKeyValueFileSystem.prototype._syncSync = function _syncSync (p, data, stats) {\n        // @todo Ensure mtime updates properly, and use that to determine if a data\n        //       update is required.\n        var tx = this.store.beginTransaction('readwrite'), \n        // We use the _findInode helper because we actually need the INode id.\n        fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\n        try {\n            // Sync data.\n            tx.put(fileInode.id, data, true);\n            // Sync metadata.\n            if (inodeChanged) {\n                tx.put(fileInodeId, fileInode.toBuffer(), true);\n            }\n        }\n        catch (e) {\n            tx.abort();\n            throw e;\n        }\n        tx.commit();\n    };\n    /**\n     * Checks if the root directory exists. Creates it if it doesn't.\n     */\n    SyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory () {\n        var tx = this.store.beginTransaction('readwrite');\n        if (tx.get(ROOT_NODE_ID) === undefined) {\n            // Create new inode.\n            var currTime = (new Date()).getTime(), \n            // Mode 0666\n            dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n            // If the root doesn't exist, the first random ID shouldn't exist,\n            // either.\n            tx.put(dirInode.id, getEmptyDirNode(), false);\n            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\n            tx.commit();\n        }\n    };\n    /**\n     * Helper function for findINode.\n     * @param parent The parent directory of the file we are attempting to find.\n     * @param filename The filename of the inode we are attempting to find, minus\n     *   the parent.\n     * @return string The ID of the file's inode in the file system.\n     */\n    SyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename) {\n        var this$1 = this;\n\n        var readDirectory = function (inode) {\n            // Get the root's directory listing.\n            var dirList = this$1.getDirListing(tx, parent, inode);\n            // Get the file's ID.\n            if (dirList[filename]) {\n                return dirList[filename];\n            }\n            else {\n                throw ApiError.ENOENT(path.resolve(parent, filename));\n            }\n        };\n        if (parent === '/') {\n            if (filename === '') {\n                // BASE CASE #1: Return the root's ID.\n                return ROOT_NODE_ID;\n            }\n            else {\n                // BASE CASE #2: Find the item in the root ndoe.\n                return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\n            }\n        }\n        else {\n            return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\n        }\n    };\n    /**\n     * Finds the Inode of the given path.\n     * @param p The path to look up.\n     * @return The Inode of the path p.\n     * @todo memoize/cache\n     */\n    SyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p) {\n        return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\n    };\n    /**\n     * Given the ID of a node, retrieves the corresponding Inode.\n     * @param tx The transaction to use.\n     * @param p The corresponding path to the file (used for error messages).\n     * @param id The ID to look up.\n     */\n    SyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id) {\n        var inode = tx.get(id);\n        if (inode === undefined) {\n            throw ApiError.ENOENT(p);\n        }\n        return Inode.fromBuffer(inode);\n    };\n    /**\n     * Given the Inode of a directory, retrieves the corresponding directory\n     * listing.\n     */\n    SyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode) {\n        if (!inode.isDirectory()) {\n            throw ApiError.ENOTDIR(p);\n        }\n        var data = tx.get(inode.id);\n        if (data === undefined) {\n            throw ApiError.ENOENT(p);\n        }\n        return JSON.parse(data.toString());\n    };\n    /**\n     * Creates a new node under a random ID. Retries 5 times before giving up in\n     * the exceedingly unlikely chance that we try to reuse a random GUID.\n     * @return The GUID that the data was stored under.\n     */\n    SyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data) {\n        var retries = 0;\n        var currId;\n        while (retries < 5) {\n            try {\n                currId = GenerateRandomID();\n                tx.put(currId, data, false);\n                return currId;\n            }\n            catch (e) {\n                // Ignore and reroll.\n            }\n        }\n        throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');\n    };\n    /**\n     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n     * the given mode.\n     * Note: This will commit the transaction.\n     * @param p The path to the new file.\n     * @param type The type of the new file.\n     * @param mode The mode to create the new file with.\n     * @param data The data to store at the file's data node.\n     * @return The Inode for the new file.\n     */\n    SyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data) {\n        var parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\n        // Invariant: The root always exists.\n        // If we don't check this prior to taking steps below, we will create a\n        // file with name '' in root should p == '/'.\n        if (p === '/') {\n            throw ApiError.EEXIST(p);\n        }\n        // Check if file already exists.\n        if (dirListing[fname]) {\n            throw ApiError.EEXIST(p);\n        }\n        var fileNode;\n        try {\n            // Commit data.\n            var dataId = this.addNewNode(tx, data);\n            fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n            // Commit file node.\n            var fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\n            // Update and commit parent directory listing.\n            dirListing[fname] = fileNodeId;\n            tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\n        }\n        catch (e) {\n            tx.abort();\n            throw e;\n        }\n        tx.commit();\n        return fileNode;\n    };\n    /**\n     * Remove all traces of the given path from the file system.\n     * @param p The path to remove from the file system.\n     * @param isDir Does the path belong to a directory, or a file?\n     * @todo Update mtime.\n     */\n    SyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir) {\n        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\n        if (!parentListing[fileName]) {\n            throw ApiError.ENOENT(p);\n        }\n        // Remove from directory listing of parent.\n        var fileNodeId = parentListing[fileName];\n        delete parentListing[fileName];\n        // Get file inode.\n        var fileNode = this.getINode(tx, p, fileNodeId);\n        if (!isDir && fileNode.isDirectory()) {\n            throw ApiError.EISDIR(p);\n        }\n        else if (isDir && !fileNode.isDirectory()) {\n            throw ApiError.ENOTDIR(p);\n        }\n        try {\n            // Delete data.\n            tx.del(fileNode.id);\n            // Delete node.\n            tx.del(fileNodeId);\n            // Update directory listing.\n            tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\n        }\n        catch (e) {\n            tx.abort();\n            throw e;\n        }\n        // Success.\n        tx.commit();\n    };\n\n    return SyncKeyValueFileSystem;\n}(SynchronousFileSystem));\nvar AsyncKeyValueFile = (function (PreloadFile$$1) {\n    function AsyncKeyValueFile(_fs, _path, _flag, _stat, contents) {\n        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);\n    }\n\n    if ( PreloadFile$$1 ) AsyncKeyValueFile.__proto__ = PreloadFile$$1;\n    AsyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );\n    AsyncKeyValueFile.prototype.constructor = AsyncKeyValueFile;\n    AsyncKeyValueFile.prototype.sync = function sync (cb) {\n        var this$1 = this;\n\n        if (this.isDirty()) {\n            this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), function (e) {\n                if (!e) {\n                    this$1.resetDirty();\n                }\n                cb(e);\n            });\n        }\n        else {\n            cb();\n        }\n    };\n    AsyncKeyValueFile.prototype.close = function close (cb) {\n        this.sync(cb);\n    };\n\n    return AsyncKeyValueFile;\n}(PreloadFile));\n/**\n * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\n * an underlying asynchronous key-value store.\n */\nvar AsyncKeyValueFileSystem = (function (BaseFileSystem$$1) {\n    function AsyncKeyValueFileSystem(cacheSize) {\n        BaseFileSystem$$1.call(this);\n        this._cache = null;\n        if (cacheSize > 0) {\n            this._cache = new LRUCache(cacheSize);\n        }\n    }\n\n    if ( BaseFileSystem$$1 ) AsyncKeyValueFileSystem.__proto__ = BaseFileSystem$$1;\n    AsyncKeyValueFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );\n    AsyncKeyValueFileSystem.prototype.constructor = AsyncKeyValueFileSystem;\n    AsyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };\n    /**\n     * Initializes the file system. Typically called by subclasses' async\n     * constructors.\n     */\n    AsyncKeyValueFileSystem.prototype.init = function init (store, cb) {\n        this.store = store;\n        // INVARIANT: Ensure that the root exists.\n        this.makeRootDirectory(cb);\n    };\n    AsyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };\n    AsyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };\n    AsyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };\n    AsyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };\n    AsyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return false; };\n    /**\n     * Delete all contents stored in the file system.\n     */\n    AsyncKeyValueFileSystem.prototype.empty = function empty (cb) {\n        var this$1 = this;\n\n        if (this._cache) {\n            this._cache.removeAll();\n        }\n        this.store.clear(function (e) {\n            if (noError(e, cb)) {\n                // INVARIANT: Root always exists.\n                this$1.makeRootDirectory(cb);\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {\n        var this$1 = this;\n\n        // TODO: Make rename compatible with the cache.\n        if (this._cache) {\n            // Clear and disable cache during renaming process.\n            var c = this._cache;\n            this._cache = null;\n            c.removeAll();\n            var oldCb = cb;\n            cb = function (e) {\n                // Restore empty cache.\n                this$1._cache = c;\n                oldCb(e);\n            };\n        }\n        var tx = this.store.beginTransaction('readwrite');\n        var oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);\n        var newParent = path.dirname(newPath), newName = path.basename(newPath);\n        var inodes = {};\n        var lists = {};\n        var errorOccurred = false;\n        // Invariant: Can't move a folder inside itself.\n        // This funny little hack ensures that the check passes only if oldPath\n        // is a subpath of newParent. We append '/' to avoid matching folders that\n        // are a substring of the bottom-most folder in the path.\n        if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n            return cb(new ApiError(ErrorCode.EBUSY, oldParent));\n        }\n        /**\n         * Responsible for Phase 2 of the rename operation: Modifying and\n         * committing the directory listings. Called once we have successfully\n         * retrieved both the old and new parent's inodes and listings.\n         */\n        var theOleSwitcharoo = function () {\n            // Sanity check: Ensure both paths are present, and no error has occurred.\n            if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\n                return;\n            }\n            var oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\n            // Delete file from old parent.\n            if (!oldParentList[oldName]) {\n                cb(ApiError.ENOENT(oldPath));\n            }\n            else {\n                var fileId = oldParentList[oldName];\n                delete oldParentList[oldName];\n                // Finishes off the renaming process by adding the file to the new\n                // parent.\n                var completeRename = function () {\n                    newParentList[newName] = fileId;\n                    // Commit old parent's list.\n                    tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, function (e) {\n                        if (noErrorTx(e, tx, cb)) {\n                            if (oldParent === newParent) {\n                                // DONE!\n                                tx.commit(cb);\n                            }\n                            else {\n                                // Commit new parent's list.\n                                tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, function (e) {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        tx.commit(cb);\n                                    }\n                                });\n                            }\n                        }\n                    });\n                };\n                if (newParentList[newName]) {\n                    // 'newPath' already exists. Check if it's a file or a directory, and\n                    // act accordingly.\n                    this$1.getINode(tx, newPath, newParentList[newName], function (e, inode) {\n                        if (noErrorTx(e, tx, cb)) {\n                            if (inode.isFile()) {\n                                // Delete the file and continue.\n                                tx.del(inode.id, function (e) {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        tx.del(newParentList[newName], function (e) {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                completeRename();\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                            else {\n                                // Can't overwrite a directory using rename.\n                                tx.abort(function (e) {\n                                    cb(ApiError.EPERM(newPath));\n                                });\n                            }\n                        }\n                    });\n                }\n                else {\n                    completeRename();\n                }\n            }\n        };\n        /**\n         * Grabs a path's inode and directory listing, and shoves it into the\n         * inodes and lists hashes.\n         */\n        var processInodeAndListings = function (p) {\n            this$1.findINodeAndDirListing(tx, p, function (e, node, dirList) {\n                if (e) {\n                    if (!errorOccurred) {\n                        errorOccurred = true;\n                        tx.abort(function () {\n                            cb(e);\n                        });\n                    }\n                    // If error has occurred already, just stop here.\n                }\n                else {\n                    inodes[p] = node;\n                    lists[p] = dirList;\n                    theOleSwitcharoo();\n                }\n            });\n        };\n        processInodeAndListings(oldParent);\n        if (oldParent !== newParent) {\n            processInodeAndListings(newParent);\n        }\n    };\n    AsyncKeyValueFileSystem.prototype.stat = function stat (p, isLstat, cb) {\n        var tx = this.store.beginTransaction('readonly');\n        this.findINode(tx, p, function (e, inode) {\n            if (noError(e, cb)) {\n                cb(null, inode.toStats());\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {\n        var this$1 = this;\n\n        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\n        this.commitNewFile(tx, p, FileType.FILE, mode, data, function (e, newFile) {\n            if (noError(e, cb)) {\n                cb(null, new AsyncKeyValueFile(this$1, p, flag, newFile.toStats(), data));\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype.openFile = function openFile (p, flag, cb) {\n        var this$1 = this;\n\n        var tx = this.store.beginTransaction('readonly');\n        // Step 1: Grab the file's inode.\n        this.findINode(tx, p, function (e, inode) {\n            if (noError(e, cb)) {\n                // Step 2: Grab the file's data.\n                tx.get(inode.id, function (e, data) {\n                    if (noError(e, cb)) {\n                        if (data === undefined) {\n                            cb(ApiError.ENOENT(p));\n                        }\n                        else {\n                            cb(null, new AsyncKeyValueFile(this$1, p, flag, inode.toStats(), data));\n                        }\n                    }\n                });\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype.unlink = function unlink (p, cb) {\n        this.removeEntry(p, false, cb);\n    };\n    AsyncKeyValueFileSystem.prototype.rmdir = function rmdir (p, cb) {\n        var this$1 = this;\n\n        // Check first if directory is empty.\n        this.readdir(p, function (err, files) {\n            if (err) {\n                cb(err);\n            }\n            else if (files.length > 0) {\n                cb(ApiError.ENOTEMPTY(p));\n            }\n            else {\n                this$1.removeEntry(p, true, cb);\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {\n        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\n    };\n    AsyncKeyValueFileSystem.prototype.readdir = function readdir (p, cb) {\n        var this$1 = this;\n\n        var tx = this.store.beginTransaction('readonly');\n        this.findINode(tx, p, function (e, inode) {\n            if (noError(e, cb)) {\n                this$1.getDirListing(tx, p, inode, function (e, dirListing) {\n                    if (noError(e, cb)) {\n                        cb(null, Object.keys(dirListing));\n                    }\n                });\n            }\n        });\n    };\n    AsyncKeyValueFileSystem.prototype._sync = function _sync (p, data, stats, cb) {\n        var this$1 = this;\n\n        // @todo Ensure mtime updates properly, and use that to determine if a data\n        //       update is required.\n        var tx = this.store.beginTransaction('readwrite');\n        // Step 1: Get the file node's ID.\n        this._findINode(tx, path.dirname(p), path.basename(p), function (e, fileInodeId) {\n            if (noErrorTx(e, tx, cb)) {\n                // Step 2: Get the file inode.\n                this$1.getINode(tx, p, fileInodeId, function (e, fileInode) {\n                    if (noErrorTx(e, tx, cb)) {\n                        var inodeChanged = fileInode.update(stats);\n                        // Step 3: Sync the data.\n                        tx.put(fileInode.id, data, true, function (e) {\n                            if (noErrorTx(e, tx, cb)) {\n                                // Step 4: Sync the metadata (if it changed)!\n                                if (inodeChanged) {\n                                    tx.put(fileInodeId, fileInode.toBuffer(), true, function (e) {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.commit(cb);\n                                        }\n                                    });\n                                }\n                                else {\n                                    // No need to sync metadata; return.\n                                    tx.commit(cb);\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * Checks if the root directory exists. Creates it if it doesn't.\n     */\n    AsyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory (cb) {\n        var tx = this.store.beginTransaction('readwrite');\n        tx.get(ROOT_NODE_ID, function (e, data) {\n            if (e || data === undefined) {\n                // Create new inode.\n                var currTime = (new Date()).getTime(), \n                // Mode 0666\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                // If the root doesn't exist, the first random ID shouldn't exist,\n                // either.\n                tx.put(dirInode.id, getEmptyDirNode(), false, function (e) {\n                    if (noErrorTx(e, tx, cb)) {\n                        tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, function (e) {\n                            if (e) {\n                                tx.abort(function () { cb(e); });\n                            }\n                            else {\n                                tx.commit(cb);\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                // We're good.\n                tx.commit(cb);\n            }\n        });\n    };\n    /**\n     * Helper function for findINode.\n     * @param parent The parent directory of the file we are attempting to find.\n     * @param filename The filename of the inode we are attempting to find, minus\n     *   the parent.\n     * @param cb Passed an error or the ID of the file's inode in the file system.\n     */\n    AsyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename, cb) {\n        var this$1 = this;\n\n        if (this._cache) {\n            var id = this._cache.get(path.join(parent, filename));\n            if (id) {\n                return cb(null, id);\n            }\n        }\n        var handleDirectoryListings = function (e, inode, dirList) {\n            if (e) {\n                cb(e);\n            }\n            else if (dirList[filename]) {\n                var id = dirList[filename];\n                if (this$1._cache) {\n                    this$1._cache.set(path.join(parent, filename), id);\n                }\n                cb(null, id);\n            }\n            else {\n                cb(ApiError.ENOENT(path.resolve(parent, filename)));\n            }\n        };\n        if (parent === '/') {\n            if (filename === '') {\n                // BASE CASE #1: Return the root's ID.\n                if (this._cache) {\n                    this._cache.set(path.join(parent, filename), ROOT_NODE_ID);\n                }\n                cb(null, ROOT_NODE_ID);\n            }\n            else {\n                // BASE CASE #2: Find the item in the root node.\n                this.getINode(tx, parent, ROOT_NODE_ID, function (e, inode) {\n                    if (noError(e, cb)) {\n                        this$1.getDirListing(tx, parent, inode, function (e, dirList) {\n                            // handle_directory_listings will handle e for us.\n                            handleDirectoryListings(e, inode, dirList);\n                        });\n                    }\n                });\n            }\n        }\n        else {\n            // Get the parent directory's INode, and find the file in its directory\n            // listing.\n            this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\n        }\n    };\n    /**\n     * Finds the Inode of the given path.\n     * @param p The path to look up.\n     * @param cb Passed an error or the Inode of the path p.\n     * @todo memoize/cache\n     */\n    AsyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p, cb) {\n        var this$1 = this;\n\n        this._findINode(tx, path.dirname(p), path.basename(p), function (e, id) {\n            if (noError(e, cb)) {\n                this$1.getINode(tx, p, id, cb);\n            }\n        });\n    };\n    /**\n     * Given the ID of a node, retrieves the corresponding Inode.\n     * @param tx The transaction to use.\n     * @param p The corresponding path to the file (used for error messages).\n     * @param id The ID to look up.\n     * @param cb Passed an error or the inode under the given id.\n     */\n    AsyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id, cb) {\n        tx.get(id, function (e, data) {\n            if (noError(e, cb)) {\n                if (data === undefined) {\n                    cb(ApiError.ENOENT(p));\n                }\n                else {\n                    cb(null, Inode.fromBuffer(data));\n                }\n            }\n        });\n    };\n    /**\n     * Given the Inode of a directory, retrieves the corresponding directory\n     * listing.\n     */\n    AsyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode, cb) {\n        if (!inode.isDirectory()) {\n            cb(ApiError.ENOTDIR(p));\n        }\n        else {\n            tx.get(inode.id, function (e, data) {\n                if (noError(e, cb)) {\n                    try {\n                        cb(null, JSON.parse(data.toString()));\n                    }\n                    catch (e) {\n                        // Occurs when data is undefined, or corresponds to something other\n                        // than a directory listing. The latter should never occur unless\n                        // the file system is corrupted.\n                        cb(ApiError.ENOENT(p));\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * Given a path to a directory, retrieves the corresponding INode and\n     * directory listing.\n     */\n    AsyncKeyValueFileSystem.prototype.findINodeAndDirListing = function findINodeAndDirListing (tx, p, cb) {\n        var this$1 = this;\n\n        this.findINode(tx, p, function (e, inode) {\n            if (noError(e, cb)) {\n                this$1.getDirListing(tx, p, inode, function (e, listing) {\n                    if (noError(e, cb)) {\n                        cb(null, inode, listing);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * Adds a new node under a random ID. Retries 5 times before giving up in\n     * the exceedingly unlikely chance that we try to reuse a random GUID.\n     * @param cb Passed an error or the GUID that the data was stored under.\n     */\n    AsyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data, cb) {\n        var retries = 0, currId;\n        var reroll = function () {\n            if (++retries === 5) {\n                // Max retries hit. Return with an error.\n                cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));\n            }\n            else {\n                // Try again.\n                currId = GenerateRandomID();\n                tx.put(currId, data, false, function (e, committed) {\n                    if (e || !committed) {\n                        reroll();\n                    }\n                    else {\n                        // Successfully stored under 'currId'.\n                        cb(null, currId);\n                    }\n                });\n            }\n        };\n        reroll();\n    };\n    /**\n     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n     * the given mode.\n     * Note: This will commit the transaction.\n     * @param p The path to the new file.\n     * @param type The type of the new file.\n     * @param mode The mode to create the new file with.\n     * @param data The data to store at the file's data node.\n     * @param cb Passed an error or the Inode for the new file.\n     */\n    AsyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data, cb) {\n        var this$1 = this;\n\n        var parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();\n        // Invariant: The root always exists.\n        // If we don't check this prior to taking steps below, we will create a\n        // file with name '' in root should p == '/'.\n        if (p === '/') {\n            return cb(ApiError.EEXIST(p));\n        }\n        // Let's build a pyramid of code!\n        // Step 1: Get the parent directory's inode and directory listing\n        this.findINodeAndDirListing(tx, parentDir, function (e, parentNode, dirListing) {\n            if (noErrorTx(e, tx, cb)) {\n                if (dirListing[fname]) {\n                    // File already exists.\n                    tx.abort(function () {\n                        cb(ApiError.EEXIST(p));\n                    });\n                }\n                else {\n                    // Step 2: Commit data to store.\n                    this$1.addNewNode(tx, data, function (e, dataId) {\n                        if (noErrorTx(e, tx, cb)) {\n                            // Step 3: Commit the file's inode to the store.\n                            var fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                            this$1.addNewNode(tx, fileInode.toBuffer(), function (e, fileInodeId) {\n                                if (noErrorTx(e, tx, cb)) {\n                                    // Step 4: Update parent directory's listing.\n                                    dirListing[fname] = fileInodeId;\n                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, function (e) {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            // Step 5: Commit and return the new inode.\n                                            tx.commit(function (e) {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    cb(null, fileInode);\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    };\n    /**\n     * Remove all traces of the given path from the file system.\n     * @param p The path to remove from the file system.\n     * @param isDir Does the path belong to a directory, or a file?\n     * @todo Update mtime.\n     */\n    AsyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir, cb) {\n        var this$1 = this;\n\n        // Eagerly delete from cache (harmless even if removal fails)\n        if (this._cache) {\n            this._cache.remove(p);\n        }\n        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);\n        // Step 1: Get parent directory's node and directory listing.\n        this.findINodeAndDirListing(tx, parent, function (e, parentNode, parentListing) {\n            if (noErrorTx(e, tx, cb)) {\n                if (!parentListing[fileName]) {\n                    tx.abort(function () {\n                        cb(ApiError.ENOENT(p));\n                    });\n                }\n                else {\n                    // Remove from directory listing of parent.\n                    var fileNodeId = parentListing[fileName];\n                    delete parentListing[fileName];\n                    // Step 2: Get file inode.\n                    this$1.getINode(tx, p, fileNodeId, function (e, fileNode) {\n                        if (noErrorTx(e, tx, cb)) {\n                            if (!isDir && fileNode.isDirectory()) {\n                                tx.abort(function () {\n                                    cb(ApiError.EISDIR(p));\n                                });\n                            }\n                            else if (isDir && !fileNode.isDirectory()) {\n                                tx.abort(function () {\n                                    cb(ApiError.ENOTDIR(p));\n                                });\n                            }\n                            else {\n                                // Step 3: Delete data.\n                                tx.del(fileNode.id, function (e) {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        // Step 4: Delete node.\n                                        tx.del(fileNodeId, function (e) {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                // Step 5: Update directory listing.\n                                                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, function (e) {\n                                                    if (noErrorTx(e, tx, cb)) {\n                                                        tx.commit(cb);\n                                                    }\n                                                });\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    };\n\n    return AsyncKeyValueFileSystem;\n}(BaseFileSystem));\n\n/**\n * A simple in-memory key-value store backed by a JavaScript object.\n */\nvar InMemoryStore = function InMemoryStore() {\n    this.store = {};\n};\nInMemoryStore.prototype.name = function name () { return InMemoryFileSystem.Name; };\nInMemoryStore.prototype.clear = function clear () { this.store = {}; };\nInMemoryStore.prototype.beginTransaction = function beginTransaction (type) {\n    return new SimpleSyncRWTransaction(this);\n};\nInMemoryStore.prototype.get = function get (key) {\n    return this.store[key];\n};\nInMemoryStore.prototype.put = function put (key, data, overwrite) {\n    if (!overwrite && this.store.hasOwnProperty(key)) {\n        return false;\n    }\n    this.store[key] = data;\n    return true;\n};\nInMemoryStore.prototype.del = function del (key) {\n    delete this.store[key];\n};\n/**\n * A simple in-memory file system backed by an InMemoryStore.\n * Files are not persisted across page loads.\n */\nvar InMemoryFileSystem = (function (SyncKeyValueFileSystem$$1) {\n    function InMemoryFileSystem() {\n        SyncKeyValueFileSystem$$1.call(this, { store: new InMemoryStore() });\n    }\n\n    if ( SyncKeyValueFileSystem$$1 ) InMemoryFileSystem.__proto__ = SyncKeyValueFileSystem$$1;\n    InMemoryFileSystem.prototype = Object.create( SyncKeyValueFileSystem$$1 && SyncKeyValueFileSystem$$1.prototype );\n    InMemoryFileSystem.prototype.constructor = InMemoryFileSystem;\n    /**\n     * Creates an InMemoryFileSystem instance.\n     */\n    InMemoryFileSystem.Create = function Create (options, cb) {\n        cb(null, new InMemoryFileSystem());\n    };\n\n    return InMemoryFileSystem;\n}(SyncKeyValueFileSystem));\nInMemoryFileSystem.Name = \"InMemory\";\nInMemoryFileSystem.Options = {};\n\n/**\n * Get the indexedDB constructor for the current browser.\n * @hidden\n */\nvar indexedDB = toExport.indexedDB ||\n    toExport.mozIndexedDB ||\n    toExport.webkitIndexedDB ||\n    toExport.msIndexedDB;\n/**\n * Converts a DOMException or a DOMError from an IndexedDB event into a\n * standardized BrowserFS API error.\n * @hidden\n */\nfunction convertError(e, message) {\n    if ( message === void 0 ) message = e.toString();\n\n    switch (e.name) {\n        case \"NotFoundError\":\n            return new ApiError(ErrorCode.ENOENT, message);\n        case \"QuotaExceededError\":\n            return new ApiError(ErrorCode.ENOSPC, message);\n        default:\n            // The rest do not seem to map cleanly to standard error codes.\n            return new ApiError(ErrorCode.EIO, message);\n    }\n}\n/**\n * Produces a new onerror handler for IDB. Our errors are always fatal, so we\n * handle them generically: Call the user-supplied callback with a translated\n * version of the error, and let the error bubble up.\n * @hidden\n */\nfunction onErrorHandler(cb, code, message) {\n    if ( code === void 0 ) code = ErrorCode.EIO;\n    if ( message === void 0 ) message = null;\n\n    return function (e) {\n        // Prevent the error from canceling the transaction.\n        e.preventDefault();\n        cb(new ApiError(code, message !== null ? message : undefined));\n    };\n}\n/**\n * @hidden\n */\nvar IndexedDBROTransaction = function IndexedDBROTransaction(tx, store) {\n    this.tx = tx;\n    this.store = store;\n};\nIndexedDBROTransaction.prototype.get = function get (key, cb) {\n    try {\n        var r = this.store.get(key);\n        r.onerror = onErrorHandler(cb);\n        r.onsuccess = function (event) {\n            // IDB returns the value 'undefined' when you try to get keys that\n            // don't exist. The caller expects this behavior.\n            var result = event.target.result;\n            if (result === undefined) {\n                cb(null, result);\n            }\n            else {\n                // IDB data is stored as an ArrayBuffer\n                cb(null, arrayBuffer2Buffer(result));\n            }\n        };\n    }\n    catch (e) {\n        cb(convertError(e));\n    }\n};\n/**\n * @hidden\n */\nvar IndexedDBRWTransaction = (function (IndexedDBROTransaction) {\n    function IndexedDBRWTransaction(tx, store) {\n        IndexedDBROTransaction.call(this, tx, store);\n    }\n\n    if ( IndexedDBROTransaction ) IndexedDBRWTransaction.__proto__ = IndexedDBROTransaction;\n    IndexedDBRWTransaction.prototype = Object.create( IndexedDBROTransaction && IndexedDBROTransaction.prototype );\n    IndexedDBRWTransaction.prototype.constructor = IndexedDBRWTransaction;\n    IndexedDBRWTransaction.prototype.put = function put (key, data, overwrite, cb) {\n        try {\n            var arraybuffer = buffer2ArrayBuffer(data);\n            var r;\n            // Note: 'add' will never overwrite an existing key.\n            r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\n            // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\n            r.onerror = onErrorHandler(cb);\n            r.onsuccess = function (event) {\n                cb(null, true);\n            };\n        }\n        catch (e) {\n            cb(convertError(e));\n        }\n    };\n    IndexedDBRWTransaction.prototype.del = function del (key, cb) {\n        try {\n            // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\n            // like this.\n            // http://stackoverflow.com/a/26479152\n            var r = this.store['delete'](key);\n            r.onerror = onErrorHandler(cb);\n            r.onsuccess = function (event) {\n                cb();\n            };\n        }\n        catch (e) {\n            cb(convertError(e));\n        }\n    };\n    IndexedDBRWTransaction.prototype.commit = function commit (cb) {\n        // Return to the event loop to commit the transaction.\n        setTimeout(cb, 0);\n    };\n    IndexedDBRWTransaction.prototype.abort = function abort (cb) {\n        var _e = null;\n        try {\n            this.tx.abort();\n        }\n        catch (e) {\n            _e = convertError(e);\n        }\n        finally {\n            cb(_e);\n        }\n    };\n\n    return IndexedDBRWTransaction;\n}(IndexedDBROTransaction));\nvar IndexedDBStore = function IndexedDBStore(db, storeName) {\n    this.db = db;\n    this.storeName = storeName;\n};\nIndexedDBStore.Create = function Create (storeName, cb) {\n    var openReq = indexedDB.open(storeName, 1);\n    openReq.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        // Huh. This should never happen; we're at version 1. Why does another\n        // database exist?\n        if (db.objectStoreNames.contains(storeName)) {\n            db.deleteObjectStore(storeName);\n        }\n        db.createObjectStore(storeName);\n    };\n    openReq.onsuccess = function (event) {\n        cb(null, new IndexedDBStore(event.target.result, storeName));\n    };\n    openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);\n};\nIndexedDBStore.prototype.name = function name () {\n    return IndexedDBFileSystem.Name + \" - \" + this.storeName;\n};\nIndexedDBStore.prototype.clear = function clear (cb) {\n    try {\n        var tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\n        r.onsuccess = function (event) {\n            // Use setTimeout to commit transaction.\n            setTimeout(cb, 0);\n        };\n        r.onerror = onErrorHandler(cb);\n    }\n    catch (e) {\n        cb(convertError(e));\n    }\n};\nIndexedDBStore.prototype.beginTransaction = function beginTransaction (type) {\n        if ( type === void 0 ) type = 'readonly';\n\n    var tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\n    if (type === 'readwrite') {\n        return new IndexedDBRWTransaction(tx, objectStore);\n    }\n    else if (type === 'readonly') {\n        return new IndexedDBROTransaction(tx, objectStore);\n    }\n    else {\n        throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');\n    }\n};\n/**\n * A file system that uses the IndexedDB key value file system.\n */\nvar IndexedDBFileSystem = (function (AsyncKeyValueFileSystem$$1) {\n    function IndexedDBFileSystem(cacheSize) {\n        AsyncKeyValueFileSystem$$1.call(this, cacheSize);\n    }\n\n    if ( AsyncKeyValueFileSystem$$1 ) IndexedDBFileSystem.__proto__ = AsyncKeyValueFileSystem$$1;\n    IndexedDBFileSystem.prototype = Object.create( AsyncKeyValueFileSystem$$1 && AsyncKeyValueFileSystem$$1.prototype );\n    IndexedDBFileSystem.prototype.constructor = IndexedDBFileSystem;\n    /**\n     * Constructs an IndexedDB file system with the given options.\n     */\n    IndexedDBFileSystem.Create = function Create (opts, cb) {\n        IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', function (e, store) {\n            if (store) {\n                var idbfs = new IndexedDBFileSystem(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\n                idbfs.init(store, function (e) {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, idbfs);\n                    }\n                });\n            }\n            else {\n                cb(e);\n            }\n        });\n    };\n    IndexedDBFileSystem.isAvailable = function isAvailable () {\n        // In Safari's private browsing mode, indexedDB.open returns NULL.\n        // In Firefox, it throws an exception.\n        // In Chrome, it \"just works\", and clears the database when you leave the page.\n        // Untested: Opera, IE.\n        try {\n            return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\n        }\n        catch (e) {\n            return false;\n        }\n    };\n\n    return IndexedDBFileSystem;\n}(AsyncKeyValueFileSystem));\nIndexedDBFileSystem.Name = \"IndexedDB\";\nIndexedDBFileSystem.Options = {\n    storeName: {\n        type: \"string\",\n        optional: true,\n        description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\n    },\n    cacheSize: {\n        type: \"number\",\n        optional: true,\n        description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\n    }\n};\n\n// Monkey-patch `Create` functions to check options before file system initialization.\n[InMemoryFileSystem, IndexedDBFileSystem].forEach(function (fsType) {\n    var create = fsType.Create;\n    fsType.Create = function (opts, cb) {\n        var oneArg = typeof (opts) === \"function\";\n        var normalizedCb = oneArg ? opts : cb;\n        var normalizedOpts = oneArg ? {} : opts;\n        function wrappedCb(e) {\n            if (e) {\n                normalizedCb(e);\n            }\n            else {\n                create.call(fsType, normalizedOpts, normalizedCb);\n            }\n        }\n        checkOptions(fsType, normalizedOpts, wrappedCb);\n    };\n});\n/**\n * @hidden\n */\nvar Backends = { InMemory: InMemoryFileSystem, IndexedDB: IndexedDBFileSystem };\n\n/**\n * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.\n * Due to limitations in typedoc, we document these functions in ./typedoc.ts.\n */\nif (process['initializeTTYs']) {\n    process['initializeTTYs']();\n}\n/**\n * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,\n * and a Node process polyfill as the global `process` variable.\n */\nfunction install(obj) {\n    obj.Buffer = Buffer;\n    obj.process = process;\n    var oldRequire = obj.require ? obj.require : null;\n    // Monkey-patch require for Node-style code.\n    obj.require = function (arg) {\n        var rv = BFSRequire(arg);\n        if (!rv) {\n            return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));\n        }\n        else {\n            return rv;\n        }\n    };\n}\n/**\n * @hidden\n */\nfunction registerFileSystem(name, fs) {\n    Backends[name] = fs;\n}\nfunction BFSRequire(module) {\n    switch (module) {\n        case 'fs':\n            return _fsMock;\n        case 'path':\n            return path;\n        case 'buffer':\n            // The 'buffer' module has 'Buffer' as a property.\n            return buffer;\n        case 'process':\n            return process;\n        case 'bfs_utils':\n            return BFSUtils;\n        default:\n            return Backends[module];\n    }\n}\n/**\n * Initializes BrowserFS with the given root file system.\n */\nfunction initialize(rootfs) {\n    return _fsMock.initialize(rootfs);\n}\n/**\n * Creates a file system with the given configuration, and initializes BrowserFS with it.\n * See the FileSystemConfiguration type for more info on the configuration object.\n */\nfunction configure(config, cb) {\n    getFileSystem(config, function (e, fs) {\n        if (fs) {\n            initialize(fs);\n            cb();\n        }\n        else {\n            cb(e);\n        }\n    });\n}\n/**\n * Retrieve a file system with the given configuration.\n * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\n * @param cb Called when the file system is constructed, or when an error occurs.\n */\nfunction getFileSystem(config, cb) {\n    var fsName = config['fs'];\n    if (!fsName) {\n        return cb(new ApiError(ErrorCode.EPERM, 'Missing \"fs\" property on configuration object.'));\n    }\n    var options = config['options'];\n    var waitCount = 0;\n    var called = false;\n    function finish() {\n        if (!called) {\n            called = true;\n            var fsc = Backends[fsName];\n            if (!fsc) {\n                cb(new ApiError(ErrorCode.EPERM, (\"File system \" + fsName + \" is not available in BrowserFS.\")));\n            }\n            else {\n                fsc.Create(options, cb);\n            }\n        }\n    }\n    if (options !== null && typeof (options) === \"object\") {\n        var finishedIterating = false;\n        var props = Object.keys(options).filter(function (k) { return k !== 'fs'; });\n        // Check recursively if other fields have 'fs' properties.\n        props.forEach(function (p) {\n            var d = options[p];\n            if (d !== null && typeof (d) === \"object\" && d['fs']) {\n                waitCount++;\n                getFileSystem(d, function (e, fs) {\n                    waitCount--;\n                    if (e) {\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        cb(e);\n                    }\n                    else {\n                        options[p] = fs;\n                        if (waitCount === 0 && finishedIterating) {\n                            finish();\n                        }\n                    }\n                });\n            }\n        });\n        finishedIterating = true;\n    }\n    if (waitCount === 0) {\n        finish();\n    }\n}\n\n/**\n * BrowserFS's main entry point.\n * It installs all of the needed polyfills, and requires() the main module.\n */\n// IE substr does not support negative indices\nif ('ab'.substr(-1) !== 'b') {\n    String.prototype.substr = function (substr) {\n        return function (start, length) {\n            // did we get a negative start, calculate how much it is from the\n            // beginning of the string\n            if (start < 0) {\n                start = this.length + start;\n            }\n            // call the original function\n            return substr.call(this, start, length);\n        };\n    }(String.prototype.substr);\n}\n// Polyfill for Uint8Array.prototype.slice.\n// Safari and some other browsers do not define it.\nif (typeof (ArrayBuffer) !== 'undefined' && typeof (Uint8Array) !== 'undefined') {\n    if (!Uint8Array.prototype['slice']) {\n        Uint8Array.prototype.slice = function (start, end) {\n            if ( start === void 0 ) start = 0;\n            if ( end === void 0 ) end = this.length;\n\n            var self = this;\n            if (start < 0) {\n                start = this.length + start;\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            if (end < 0) {\n                end = this.length + end;\n                if (end < 0) {\n                    end = 0;\n                }\n            }\n            if (end < start) {\n                end = start;\n            }\n            return new Uint8Array(self.buffer, self.byteOffset + start, end - start);\n        };\n    }\n}\n\nexports.install = install;\nexports.registerFileSystem = registerFileSystem;\nexports.BFSRequire = BFSRequire;\nexports.initialize = initialize;\nexports.configure = configure;\nexports.getFileSystem = getFileSystem;\nexports.EmscriptenFS = BFSEmscriptenFS;\nexports.FileSystem = Backends;\nexports.Errors = api_error;\nexports.setImmediate = setImmediate$1;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// Use path and TTY for type information only. We lazily pull them in\n// to avoid circular dependencies :(\n// (path depends on process for cwd(), TTY depends on streams which depends\n//  on process.nextTick/process.stdout/stderr/stdin).\nimport _path = require('path');\nimport _TTY = require('./tty');\nimport events = require('events');\n\n// Path depends on process. Avoid a circular reference by dynamically including path when we need it.\nvar path: typeof _path = null;\n\nclass Item {\n  private fun: Function;\n  private array: any[];\n  constructor(fun: Function, array: any[]) {\n    this.fun = fun;\n    this.array = array;\n  }\n\n  public run(): void {\n    this.fun.apply(null, this.array);\n  }\n}\n\n/**\n * Contains a queue of Items for process.nextTick.\n * Inspired by node-process: https://github.com/defunctzombie/node-process\n */\nclass NextTickQueue {\n  private _queue: Item[] = [];\n  private _draining = false;\n  // Used/assigned by the drainQueue function.\n  private _currentQueue: Item[] = null;\n  private _queueIndex = -1;\n\n  public push(item: Item): void {\n    if (this._queue.push(item) === 1 && !this._draining) {\n      setTimeout(() => this._drainQueue(), 0);\n    }\n  }\n\n  private _cleanUpNextTick() {\n    this._draining = false;\n    if (this._currentQueue && this._currentQueue.length) {\n      this._queue = this._currentQueue.concat(this._queue);\n    } else {\n      this._queueIndex = -1;\n    }\n    if (this._queue.length) {\n      this._drainQueue();\n    }\n  }\n\n  private _drainQueue() {\n    if (this._draining) {\n      return;\n    }\n    // If an Item throws an unhandled exception, this function will clean things up.\n    var timeout = setTimeout(() => this._cleanUpNextTick());\n    this._draining = true;\n\n    var len = this._queue.length;\n    while(len) {\n      this._currentQueue = this._queue;\n      this._queue = [];\n      while (++this._queueIndex < len) {\n        if (this._currentQueue) {\n          this._currentQueue[this._queueIndex].run();\n        }\n      }\n      this._queueIndex = -1;\n      len = this._queue.length;\n    }\n    this._currentQueue = null;\n    this._draining = false;\n    clearTimeout(timeout);\n  }\n}\n\n/**\n * Partial implementation of Node's `process` module.\n * We implement the portions that are relevant for the filesystem.\n * @see http://nodejs.org/api/process.html\n * @class\n */\nclass Process extends events.EventEmitter implements NodeJS.Process {\n  private startTime = Date.now();\n\n  private _cwd: string = '/';\n  /**\n   * Changes the current working directory.\n   *\n   * **Note**: BrowserFS does not validate that the directory actually exists.\n   *\n   * @example Usage example\n   *   console.log('Starting directory: ' + process.cwd());\n   *   process.chdir('/tmp');\n   *   console.log('New directory: ' + process.cwd());\n   * @param [String] dir The directory to change to.\n   */\n  public chdir(dir: string): void {\n    // XXX: Circular dependency hack.\n    if (path === null) {\n      path = require('path');\n    }\n    this._cwd = path.resolve(dir);\n  }\n  /**\n   * Returns the current working directory.\n   * @example Usage example\n   *   console.log('Current directory: ' + process.cwd());\n   * @return [String] The current working directory.\n   */\n  public cwd(): string {\n    return this._cwd;\n  }\n  /**\n   * Returns what platform you are running on.\n   * @return [String]\n   */\n  public platform: string = 'browser';\n  /**\n   * Number of seconds BrowserFS has been running.\n   * @return [Number]\n   */\n  public uptime(): number {\n    return ((Date.now() - this.startTime) / 1000) | 0;\n  }\n\n  public argv: string[] = [];\n  public execArgv: string[] = [];\n  public stdout: _TTY = null;\n  public stderr: _TTY = null;\n  public stdin: _TTY = null;\n  public domain: NodeJS.Domain = null;\n\n  private _queue: NextTickQueue = new NextTickQueue();\n\n  public nextTick(fun: any, ...args: any[]) {\n    this._queue.push(new Item(fun, args));\n  }\n\n  public execPath = __dirname;\n\n  public abort(): void {\n    this.emit('abort');\n  }\n\n  public env: {[name: string]: string} = {};\n  public exitCode: number = 0;\n  public exit(code: number): void {\n    this.exitCode = code;\n    this.emit('exit', [code]);\n  }\n\n  private _gid: number = 1;\n  public getgid(): number {\n    return this._gid;\n  }\n  public setgid(gid: number | string): void {\n    if (typeof gid === 'number') {\n      this._gid = gid;\n    } else {\n      this._gid = 1;\n    }\n  }\n\n  private _uid: number = 1;\n  public getuid(): number {\n    return this._uid;\n  }\n  public setuid(uid: number | string): void {\n    if (typeof uid === 'number') {\n      this._uid = uid;\n    } else {\n      this._uid = 1;\n    }\n  }\n\n  public version: string = 'v5.0';\n\n  public versions = {\n    http_parser: '0.0',\n    node: '5.0',\n    v8: '0.0',\n    uv: '0.0',\n    zlib: '0.0',\n    ares: '0.0',\n    icu: '0.0',\n    modules: '0',\n    openssl: '0.0'\n  };\n\n  public config = {\n    target_defaults:\n    { cflags: <any[]> [],\n      default_configuration: 'Release',\n      defines: <string[]> [],\n      include_dirs: <string[]> [],\n      libraries: <string[]> [] },\n    variables:\n    { clang: 0,\n      host_arch: 'x32',\n      node_install_npm: false,\n      node_install_waf: false,\n      node_prefix: '',\n      node_shared_cares: false,\n      node_shared_http_parser: false,\n      node_shared_libuv: false,\n      node_shared_zlib: false,\n      node_shared_v8: false,\n      node_use_dtrace: false,\n      node_use_etw: false,\n      node_use_openssl: false,\n      node_shared_openssl: false,\n      strict_aliasing: false,\n      target_arch: 'x32',\n      v8_use_snapshot: false,\n      v8_no_strict_aliasing: 0,\n      visibility: '' } };\n\n  public kill(pid: number, signal?: string): void {\n    this.emit('kill', [pid, signal]);\n  }\n\n  public pid = (Math.random()*1000)|0;\n\n  public title = 'node';\n  public arch = 'x32';\n  public memoryUsage(): {rss: number; heapTotal: number; heapUsed: number;} {\n    return { rss: 0, heapTotal: 0, heapUsed: 0 }\n  }\n\n  private _mask = 18;\n  public umask(mask: number = this._mask): number {\n    let oldMask = this._mask;\n    this._mask = mask;\n    this.emit('umask', [mask]);\n    return oldMask;\n  }\n\n  public hrtime(): [number, number] {\n    let timeinfo: number;\n    if (typeof performance !== 'undefined') {\n      timeinfo = performance.now();\n    } else if (Date['now']) {\n      timeinfo = Date.now();\n    } else {\n      timeinfo = (new Date()).getTime();\n    }\n    let secs = (timeinfo / 1000)|0;\n    timeinfo -= secs * 1000;\n    timeinfo = (timeinfo * 1000000)|0;\n    return [secs, timeinfo];\n  }\n\n  /**\n   * [BFS only] Initialize the TTY devices.\n   */\n  public initializeTTYs(): void {\n    // Guard against multiple invocations.\n    if (this.stdout === null) {\n      let TTY: typeof _TTY = require('./tty');\n      this.stdout = new TTY();\n      this.stderr = new TTY();\n      this.stdin = new TTY();\n    }\n  }\n\n  /**\n   * Worker-only function; irrelevant here.\n   */\n  public disconnect(): void {\n\n  }\n  // Undefined in main thread. Worker-only.\n  public connected: boolean = undefined;\n}\n\nexport = Process;","import stream = require('stream');\n\nclass TTY extends stream.Duplex {\n  public isRaw: boolean = false;\n  public columns: number = 80;\n  public rows: number = 120;\n  public isTTY: boolean = true;\n  private _bufferedWrites: Buffer[] = [];\n  private _waitingForWrites: boolean = false;\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Toggle raw mode.\n   */\n  public setRawMode(mode: boolean): void {\n    if (this.isRaw !== mode) {\n      this.isRaw = mode;\n      // [BFS] TTY implementations can use this to change their event emitting\n      //       patterns.\n      this.emit('modeChange');\n    }\n  }\n\n  /**\n   * [BFS] Update the number of columns available on the terminal.\n   */\n  public changeColumns(columns: number): void {\n    if (columns !== this.columns) {\n      this.columns = columns;\n      // Resize event.\n      this.emit('resize');\n    }\n  }\n\n  /**\n   * [BFS] Update the number of rows available on the terminal.\n   */\n  public changeRows(rows: number): void {\n    if (rows !== this.rows) {\n      this.rows = rows;\n      // Resize event.\n      this.emit('resize');\n    }\n  }\n\n  /**\n   * Returns 'true' if the given object is a TTY.\n   */\n  public static isatty(fd: any): fd is TTY {\n    return fd && fd instanceof TTY;\n  }\n\n  public _write(chunk: any, encoding: string, cb: Function): void {\n    var error: any;\n    try {\n      var data: Buffer;\n      if (typeof(chunk) === 'string') {\n        data = new Buffer(chunk, encoding);\n      } else {\n        data = chunk;\n      }\n      this._bufferedWrites.push(data);\n      if (this._waitingForWrites) {\n        this._read(1024);\n      }\n    } catch (e) {\n      error = e;\n    } finally {\n      cb(error);\n    }\n  }\n\n  public _read(size: number): void {\n    // Size is advisory -- we can ignore it.\n    if (this._bufferedWrites.length === 0) {\n      this._waitingForWrites = true;\n    } else {\n      while (this._bufferedWrites.length > 0) {\n        this._waitingForWrites = this.push(this._bufferedWrites.shift());\n        if (!this._waitingForWrites) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport = TTY;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","module.exports = require('./lib/_stream_writable.js');\n","module.exports = require('./lib/_stream_duplex.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./readable').PassThrough\n"],"sourceRoot":""}